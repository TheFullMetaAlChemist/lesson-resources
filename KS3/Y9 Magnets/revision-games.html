<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electromagnets Key Terms Revision Hub</title>
    <style>
        :root {
            --primary: #007BFF; /* Blue */
            --primary-light: #4DA3FF;
            --primary-dark: #0056B3;
            --secondary: #17A2B8; /* Teal / Info Blue */
            --accent: #FFC107; /* Yellow / Amber */
            --light-bg: #F8F9FA; /* Very Light Grey */
            --dark-text: #343A40; /* Dark Grey */
            --light-text: #FFFFFF;
            --success: #28A745; /* Green */
            --warning: #FFC107; /* Yellow */
            --error: #DC3545; /* Red */
            --tier1-color: var(--primary); /* Using primary for Tier 1 */
            --tier2-color: #6C757D; /* Grey for unused tiers */
            --tier3-color: #ADB5BD; /* Light Grey for unused tiers */
            --shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--light-bg);
            color: var(--dark-text);
            line-height: 1.6;
        }

        header {
            background-color: var(--primary);
            color: var(--light-text);
            padding: 1rem 2rem;
            text-align: center;
            box-shadow: var(--shadow);
            position: relative;
        }

        .app-title {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .app-subtitle {
            font-size: 1rem;
            font-weight: normal;
            opacity: 0.9;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .intro {
            text-align: center;
            margin-bottom: 2rem;
        }

        .intro p {
            max-width: 800px;
            margin: 0 auto;
        }

        .nav-wrapper {
            background-color: var(--primary-dark);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }

        .nav-btn {
            background-color: transparent;
            color: var(--light-text);
            border: none;
            padding: 1rem 1.5rem;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .nav-btn:hover {
            background-color: var(--primary);
        }

        .nav-btn.active {
            background-color: var(--primary-light);
            font-weight: bold;
        }

        .section {
            display: none;
            margin-top: 2rem;
            animation: fadeIn 0.5s ease;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .card {
            background-color: white;
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
        }

        .section-title {
            margin-bottom: 1.5rem;
            color: var(--primary-dark);
            border-bottom: 2px solid var(--primary-light);
            padding-bottom: 0.5rem;
        }

        .btn {
            display: inline-block;
            background-color: var(--primary);
            color: var(--light-text);
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: var(--transition);
            margin: 0.5rem;
        }

        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: var(--secondary);
        }

        .btn-secondary:hover {
            background-color: #117A8B; /* Darker Teal */
        }

        .btn-accent {
            background-color: var(--accent);
            color: var(--dark-text); /* Yellow needs dark text */
        }

        .btn-accent:hover {
            background-color: #E0A800; /* Darker Yellow */
        }

        .tier-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-right: 0.5rem;
            color: var(--light-text);
        }

        .tier-1 {
            background-color: var(--tier1-color);
        }

        .tier-2 {
            background-color: var(--tier2-color);
        }

        .tier-3 {
            background-color: var(--tier3-color);
        }

        .word-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .word-card {
            background-color: white;
            border-radius: 4px;
            padding: 1rem;
            box-shadow: var(--shadow);
            transition: var(--transition);
            border-left: 4px solid var(--primary-light);
        }

        .word-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }

        .word-term {
            font-weight: bold;
            color: var(--primary-dark);
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .word-definition {
            font-size: 0.9rem;
        }

        /* Flashcards */
        .flashcard-container {
            perspective: 1000px;
            width: 100%;
            max-width: 600px;
            height: 300px;
            margin: 0 auto 2rem;
        }

        .flashcard {
            width: 100%;
            height: 100%;
            position: relative;
            transition: transform 0.8s;
            transform-style: preserve-3d;
            cursor: pointer;
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
            box-shadow: var(--shadow);
        }

        .flashcard-front {
            background-color: var(--primary);
            color: var(--light-text);
            font-size: 1.5rem;
            font-weight: bold;
        }

        .flashcard-back {
            background-color: white;
            color: var(--dark-text);
            transform: rotateY(180deg);
            font-size: 1.2rem;
        }

        .flashcard-tier {
            position: absolute;
            top: 1rem;
            right: 1rem;
        }

        .flashcard-controls {
            display: flex;
            justify-content: center;
            margin-top: 1rem;
        }

        /* Matching Game */
        .matching-game {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .matching-column {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .matching-item {
            background-color: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: var(--transition);
        }

        .matching-item:hover {
            transform: translateY(-2px);
            border-left: 3px solid var(--primary-light);
        }

        .matching-item.selected {
            background-color: var(--primary-light);
            color: white;
        }

        .matching-item.matched {
            background-color: var(--success);
            color: white;
            cursor: default;
        }

        /* Splat Game */
        .splat-game {
            text-align: center;
            margin-bottom: 2rem;
        }

        .splat-board {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 1.5rem;
            max-width: 800px;
            margin: 0 auto;
        }

        .splat-word {
            background-color: white;
            padding: 3rem;
            border-radius: 8px;
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: var(--transition);
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 150px;
        }

        .splat-word:hover {
            background-color: var(--primary-light);
            color: white;
            transform: scale(1.05);
        }

        .splat-definition {
            margin: 2rem 0;
            padding: 1rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: var(--shadow);
            font-size: 1.1rem;
        }

        .splat-players {
            display: flex;
            justify-content: space-around;
            margin-bottom: 1rem;
        }

        .player-score {
            padding: 0.5rem 1rem;
            background-color: white;
            border-radius: 4px;
            box-shadow: var(--shadow);
        }

        /* Beat the Physicist (was Biologist) */
        .physicist-question {
            background-color: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: var(--shadow);
            margin-bottom: 1rem;
        }

        .physicist-term {
            font-weight: bold;
            font-size: 1.2rem;
            color: var(--primary-dark);
            margin-bottom: 0.5rem;
        }

        .physicist-definition {
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: var(--light-bg);
            border-radius: 4px;
        }

        .physicist-options {
            display: flex;
            gap: 0.5rem;
        }

        /* Pairs Game */
        .pairs-game-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .pairs-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .pair-card {
            aspect-ratio: 1;
            background-color: var(--primary);
            color: var(--light-text);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            transform-style: preserve-3d;
            position: relative;
        }

        .pair-card:hover {
            transform: scale(1.05);
        }

        .pair-card-inner {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .pair-card.flipped .pair-card-inner {
            transform: rotateY(180deg);
        }

        .pair-card-front, .pair-card-back {
            width: 100%;
            height: 100%;
            position: absolute;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            padding: 0.5rem;
            text-align: center;
        }

        .pair-card-front {
            background-color: var(--primary);
            font-size: 2rem;
        }

        .pair-card-back {
            background-color: white;
            color: var(--dark-text);
            transform: rotateY(180deg);
            font-size: 0.8rem; /* Adjusted for potentially longer definitions */
            font-weight: bold;
            line-height: 1.2;
        }

        .pair-card.matched {
            background-color: var(--success);
            cursor: default;
        }

        /* Word Search */
        .word-search-container {
            max-width: 600px;
            margin: 0 auto;
        }

        .word-search-grid {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: 1px;
            margin: 2rem 0;
            background-color: var(--primary-light);
            padding: 2px;
            border-radius: 4px;
        }

        .word-search-cell {
            aspect-ratio: 1;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }

        .word-search-cell.selected {
            background-color: var(--primary-light);
            color: white;
        }
        .word-search-cell.found { /* Added for word search found cells */
            background-color: var(--success);
            color: white;
        }

        .word-search-word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .word-search-word {
            padding: 0.5rem;
            background-color: white;
            border-radius: 4px;
            box-shadow: var(--shadow);
        }

        .word-search-word.found {
            background-color: var(--success);
            color: white;
            text-decoration: line-through;
        }

        /* Crossword */
        .crossword-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .crossword-input-area {
            position: relative;
            margin: 2rem 0;
        }

        .crossword-focus {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #crossword-active-cell {
            position: absolute;
            width: 30px; /* Will be set by JS */
            height: 30px; /* Will be set by JS */
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            border: none;
            background: transparent;
            text-transform: uppercase;
            caret-color: transparent;
            pointer-events: none; /* Input itself is not interactive */
            opacity: 0; /* Hidden, just for focus logic */
        }

        .crossword-grid {
            display: grid;
            /* grid-template-columns and rows set by JS */
            gap: 1px;
            background-color: #000;
            padding: 2px;
            border-radius: 4px;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }

        .crossword-cell {
            aspect-ratio: 1;
            background-color: white;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
        }

        .crossword-cell.black {
            background-color: #000;
            cursor: default;
        }

        .crossword-cell.active {
            background-color: var(--primary-light);
            color: white;
        }

        .crossword-cell.highlighted {
            background-color: #D1E9FF; /* Light blue highlight */
        }

        .crossword-cell.correct {
            background-color: #D4EDDA; /* Light green */
        }

        .crossword-cell.incorrect {
            background-color: #F8D7DA; /* Light red */
        }

        .crossword-cell-number {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 0.6rem;
            color: #666;
            pointer-events: none;
            z-index: 5;
        }

        .crossword-clues {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 2rem;
        }

        .crossword-clue-section h4 {
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--primary-light);
            padding-bottom: 0.5rem;
        }

        .crossword-clue {
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            padding: 0.5rem;
            border-radius: 4px;
        }

        .crossword-clue:hover {
            background-color: var(--light-bg);
        }

        .crossword-clue.active {
            background-color: var(--primary-light);
            color: white;
        }

        @media (max-width: 768px) {
            .crossword-clues {
                grid-template-columns: 1fr;
            }
        }

        /* Pictionary */
        .pictionary-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .pictionary-word-display { /* Renamed from pictionary-word to avoid conflict */
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: var(--shadow);
        }
        .pictionary-definition-display { /* Added for consistency */
             background-color: #f0f8ff; /* Alice blue for definition bg */
             padding: 1rem;
             border-radius: 8px;
             margin: 1rem 0;
             font-style: italic;
             border: 1px dashed var(--secondary);
        }

        .pictionary-image { /* This was just a placeholder, could be removed or used if actual drawing is implemented */
            width: 100%;
            height: 150px; /* Reduced height as it's just showing icon */
            background-color: white;
            border-radius: 8px;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            font-size: 3rem; /* For emoji icons */
        }

        /* Instructions */
        .instructions-list {
            list-style-type: none;
        }

        .instructions-list li {
            margin-bottom: 1rem;
            padding-left: 1.5rem;
            position: relative;
        }

        .instructions-list li::before {
            content: "💡"; /* Changed bullet point */
            color: var(--primary);
            font-size: 1.2rem;
            position: absolute;
            left: 0;
            top: 0;
        }

        .instruction-section {
            margin-bottom: 2rem;
        }

        .instruction-section h3 {
            color: var(--primary-dark);
            margin-bottom: 0.5rem;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 2rem;
            background-color: var(--primary-dark);
            color: var(--light-text);
            margin-top: 3rem;
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            .word-grid { grid-template-columns: 1fr; }
            .matching-game { grid-template-columns: 1fr; }
            .splat-board { grid-template-columns: 1fr; }
            .pairs-board { grid-template-columns: repeat(3, 1fr); }
        }

        @media (max-width: 480px) {
            .nav-btn { padding: 0.75rem; font-size: 0.9rem; }
            .pairs-board { grid-template-columns: repeat(2, 1fr); }
            .word-search-grid { grid-template-columns: repeat(10, 1fr); grid-template-rows: repeat(10, 1fr); }
        }
        
        /* Dark theme switch - kept as is for now */
        .theme-switch { position: absolute; top: 1rem; right: 1rem; display: flex; align-items: center; }
        .theme-switch label { margin-right: 0.5rem; cursor: pointer; }
        .switch { position: relative; display: inline-block; width: 40px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-light); }
        input:checked + .slider:before { transform: translateX(16px); }
        
        /* Hangman Game Styles */
        .hangman-container { display: flex; flex-wrap: wrap; gap: 2rem; justify-content: center; margin: 2rem 0; }
        .hangman-drawing { background-color: white; border-radius: 8px; padding: 1rem; box-shadow: var(--shadow); display: flex; justify-content: center; align-items: center; }
        .hangman-word-container { display: flex; flex-direction: column; gap: 1.5rem; flex-grow: 1; max-width: 500px; }
        .hangman-word { display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap; }
        .hangman-letter { width: 40px; height: 40px; border-bottom: 3px solid var(--primary-dark); display: flex; justify-content: center; align-items: center; font-size: 1.8rem; font-weight: bold; text-transform: uppercase; }
        .hangman-keyboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(40px, 1fr)); gap: 0.5rem; } /* Made keyboard more responsive */
        .keyboard-key { background-color: white; border: none; border-radius: 4px; padding: 0.5rem; font-size: 1.2rem; cursor: pointer; box-shadow: var(--shadow); transition: var(--transition); }
        .keyboard-key:hover { background-color: var(--primary-light); color: white; }
        .keyboard-key.used { background-color: #ccc; color: #666; cursor: not-allowed; }
        .keyboard-key.correct { background-color: var(--success); color: white; }
        .keyboard-key.wrong { background-color: var(--error); color: white; }
        .hangman-definition-container { margin-top: 2rem; padding: 1rem; background-color: var(--light-bg); border-radius: 8px; animation: fadeIn 0.5s ease; }
        .hangman-definitions { display: grid; grid-template-columns: 1fr; gap: 1rem; margin-top: 1rem; }
        .definition-option { background-color: white; padding: 1rem; border-radius: 8px; box-shadow: var(--shadow); cursor: pointer; transition: var(--transition); }
        .definition-option:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1); }
        .definition-option.selected { background-color: var(--primary-light); color: white; }
        .definition-option.correct { background-color: var(--success); color: white; }
        .definition-option.incorrect { background-color: var(--error); color: white; }
        .hangman-controls { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 1rem; margin-top: 1.5rem; }
        .hangman-score { font-weight: bold; padding: 0.5rem 1rem; background-color: var(--primary); color: white; border-radius: 4px; }
        .hangman-status { padding: 0.5rem 1rem; border-radius: 4px; background-color: white; flex-grow: 1; text-align: center; }

        @media (max-width: 480px) {
            .hangman-letter { width: 30px; height: 30px; font-size: 1.4rem; }
        }

    </style>
</head>
<body>
    <header>
        <div class="theme-switch">
            <label for="theme-toggle">🌙</label>
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
        <h1 class="app-title">Electromagnets Key Terms Revision Hub</h1>
        <p class="app-subtitle">KS3 Physics - Interactive Learning Resource</p>
    </header>
    
    <div class="nav-wrapper">
        <div class="nav-container">
            <button class="nav-btn active" data-section="home">Home</button>
            <button class="nav-btn" data-section="flashcards">Flashcards</button>
            <button class="nav-btn" data-section="matching">Matching</button>
            <button class="nav-btn" data-section="splat">Splat Game</button>
            <button class="nav-btn" data-section="physicist">Beat the Physicist</button> <!-- Renamed -->
            <button class="nav-btn" data-section="pairs">Pairs Game</button>
            <button class="nav-btn" data-section="wordsearch">Word Search</button>
            <button class="nav-btn" data-section="crossword">Crossword</button>
            <button class="nav-btn" data-section="pictionary">Pictionary</button>
            <button class="nav-btn" data-section="hangman">Hangman</button>
            <!-- <button class="nav-btn" data-section="instructions">Instructions</button> --> <!-- Instructions can be on home page -->
        </div>
    </div>
    
    <div class="container">
        <!-- Home Section -->
        <section id="home" class="section active">
            <div class="intro">
                <h2>Welcome to the Electromagnets Revision Hub!</h2>
                <p>Explore this interactive resource to learn key terms related to magnets and electromagnets. Choose from different activities using the navigation bar above to test and strengthen your understanding.</p>
            </div>
            
            <div class="card">
                <h3 class="section-title">Key Electromagnet Terms</h3>
                <p>This resource covers the following important terms related to electromagnetism. All terms are considered essential (Tier 1).</p>
                
                <div class="word-grid" id="home-word-grid">
                    <!-- Electromagnet terms will be populated here by JS -->
                </div>
            </div>
            
            <div class="card">
                <h3 class="section-title">Getting Started & Instructions</h3>
                <p>Select an activity from the navigation bar to begin. Here's a brief overview:</p>
                <ul class="instructions-list">
                    <li><strong>Flashcards:</strong> Memorize terms and definitions. Click to flip.</li>
                    <li><strong>Matching:</strong> Match terms to their correct definitions.</li>
                    <li><strong>Splat Game:</strong> A quick-fire game to identify terms from definitions. Best played with 2 players.</li>
                    <li><strong>Beat the Physicist:</strong> Spot incorrect definitions provided by the "Physicist".</li>
                    <li><strong>Pairs Game:</strong> Memory game to find matching terms and definitions.</li>
                    <li><strong>Word Search:</strong> Find electromagnet-related terms hidden in a grid.</li>
                    <li><strong>Crossword:</strong> Solve clues to fill in the crossword with key terms.</li>
                    <li><strong>Pictionary:</strong> Get a term and its definition, then draw it for others to guess (offline play).</li>
                    <li><strong>Hangman:</strong> Guess the letters to reveal a key term, then match its definition.</li>
                </ul>
                <p>Most games allow you to filter by term tiers (though all current terms are Tier 1). Use the "Shuffle" or "New Game" buttons within activities for fresh challenges.</p>
            </div>
        </section>
        
        <!-- Flashcards Section -->
        <section id="flashcards" class="section">
            <h2 class="section-title">Flashcards</h2>
            <div class="card">
                <p>Test your knowledge of electromagnet terms. Click on a card to flip it and reveal the definition.</p>
                
                <div class="flashcard-container">
                    <div class="flashcard">
                        <div class="flashcard-front">
                            <!-- Term -->
                            <div class="flashcard-tier">
                                <span class="tier-badge tier-1">Tier 1</span>
                            </div>
                        </div>
                        <div class="flashcard-back">
                            <!-- Definition -->
                        </div>
                    </div>
                </div>
                
                <div class="flashcard-controls">
                    <button class="btn" id="prev-card">Previous</button>
                    <button class="btn" id="next-card">Next</button>
                    <select id="tier-filter-flashcards" class="btn btn-secondary"> <!-- Unique ID -->
                        <option value="all">All Tiers</option>
                        <option value="1">Tier 1 Only</option>
                        <!-- <option value="2">Tier 2 Only</option>
                        <option value="3">Tier 3 Only</option> -->
                    </select>
                    <button class="btn btn-accent" id="shuffle-cards">Shuffle</button>
                </div>
            </div>
        </section>
        
        <!-- Matching Game Section -->
        <section id="matching" class="section">
            <h2 class="section-title">Matching Game</h2>
            <div class="card">
                <p>Match each term with its correct definition. Click a term (left), then its definition (right).</p>
                
                <div class="matching-game">
                    <div class="matching-column" id="terms-column">
                        <!-- Terms will be added here by JavaScript -->
                    </div>
                    <div class="matching-column" id="definitions-column">
                        <!-- Definitions will be added here by JavaScript -->
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <button class="btn" id="reset-matching">Reset Game</button>
                    <select id="tier-filter-matching" class="btn btn-secondary"> <!-- Unique ID -->
                        <option value="all">All Tiers</option>
                        <option value="1">Tier 1 Only</option>
                    </select>
                </div>
            </div>
        </section>
        
        <!-- Splat Game Section -->
        <section id="splat" class="section">
            <h2 class="section-title">Splat Game</h2>
            <div class="card">
                <p>Read the definition below and race to click (splat) the correct term! First player to indicate they got it gets a point.</p>
                
                <div class="splat-players">
                    <div class="player-score" id="player1-score">Player 1: 0</div>
                    <div class="player-score" id="player2-score">Player 2: 0</div>
                </div>
                
                <div class="splat-definition" id="splat-definition">
                    <!-- Definition here -->
                </div>
                
                <div class="splat-board" id="splat-board">
                    <!-- Words will be added here by JavaScript -->
                </div>
                
                <div style="text-align: center; margin-top: 1rem;">
                    <button class="btn" id="next-splat">Next Question</button>
                    <button class="btn btn-secondary" id="reset-splat-scores">Reset Scores</button> <!-- Unique ID -->
                    <select id="tier-filter-splat" class="btn btn-secondary"> <!-- Unique ID -->
                        <option value="all">All Tiers</option>
                        <option value="1">Tier 1 Only</option>
                    </select>
                </div>
            </div>
        </section>
        
        <!-- Beat the Physicist Section -->
        <section id="physicist" class="section"> <!-- Renamed from biologist -->
            <h2 class="section-title">Beat the Physicist</h2>
            <div class="card">
                <p>The Physicist has written some definitions. Can you spot if they are correct or incorrect? If incorrect, know the right one!</p>
                
                <div class="physicist-question">
                    <div class="physicist-term" id="physicist-term-display">Term</div>
                    <div class="physicist-definition" id="physicist-definition-display">Definition provided by the physicist.</div>
                    <div class="physicist-options">
                        <button class="btn" id="physicist-correct-btn">This is Correct</button>
                        <button class="btn btn-accent" id="physicist-incorrect-btn">This is Incorrect</button>
                    </div>
                </div>
                
                <div id="physicist-feedback" style="margin-top: 1rem; display: none; padding: 1rem; border-radius: 4px;">
                    <!-- Feedback will be added here by JavaScript -->
                </div>
                
                <div style="text-align: center; margin-top: 1rem;">
                    <button class="btn" id="next-physicist-q">Next Question</button> <!-- Unique ID -->
                    <div id="physicist-score-display" style="margin-top: 1rem; font-weight: bold;">Score: 0</div> <!-- Unique ID -->
                </div>
            </div>
        </section>
        
        <!-- Pairs Game Section -->
        <section id="pairs" class="section">
            <h2 class="section-title">Pairs Game</h2>
            <div class="card">
                <p>Find matching pairs of terms and definitions! Click two cards to reveal them.</p>
                
                <div class="pairs-game-container">
                    <div class="pairs-board" id="pairs-board">
                        <!-- Cards will be added here by JavaScript -->
                    </div>
                    
                    <div style="text-align: center;">
                        <button class="btn" id="reset-pairs-game">New Game</button> <!-- Unique ID -->
                        <select id="tier-filter-pairs" class="btn btn-secondary"> <!-- Unique ID -->
                            <option value="all">All Tiers</option>
                            <option value="1">Tier 1 Only</option>
                        </select>
                        <div id="pairs-moves-display" style="margin-top: 1rem;">Moves: 0</div> <!-- Unique ID -->
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Word Search Section -->
        <section id="wordsearch" class="section">
            <h2 class="section-title">Word Search</h2>
            <div class="card">
                <p>Find all the hidden electromagnet terms in this word search! Click and drag to select words.</p>
                
                <div class="word-search-container">
                    <div class="word-search-grid" id="word-search-grid">
                        <!-- Grid will be added here by JavaScript -->
                    </div>
                    
                    <div class="word-search-word-list" id="word-search-word-list">
                        <!-- Word list will be added here by JavaScript -->
                    </div>
                    
                    <div style="text-align: center; margin-top: 1rem;">
                        <button class="btn" id="new-word-search-game">New Word Search</button> <!-- Unique ID -->
                        <select id="tier-filter-wordsearch" class="btn btn-secondary"> <!-- Unique ID -->
                            <option value="all">All Tiers</option>
                            <option value="1">Tier 1 Only</option>
                        </select>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Crossword Section -->
        <section id="crossword" class="section">
            <h2 class="section-title">Crossword</h2>
            <div class="card">
                <p>Fill in the crossword puzzle with electromagnet terms based on the clues provided.</p>
                
                <div class="crossword-container">
                    <div class="crossword-input-area">
                        <div class="crossword-focus" id="crossword-focus">
                            <input type="text" id="crossword-active-cell-input" maxlength="1" autocomplete="off"> <!-- Renamed ID -->
                        </div>
                        <div class="crossword-grid" id="crossword-grid-display"> <!-- Renamed ID -->
                            <!-- Grid will be added here by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="crossword-clues">
                        <div class="crossword-clue-section">
                            <h4>Across</h4>
                            <div id="across-clues-display"> <!-- Renamed ID -->
                                <!-- Across clues will be added here by JavaScript -->
                            </div>
                        </div>
                        <div class="crossword-clue-section">
                            <h4>Down</h4>
                            <div id="down-clues-display"> <!-- Renamed ID -->
                                <!-- Down clues will be added here by JavaScript -->
                            </div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 1rem;">
                        <button class="btn" id="check-crossword-answers">Check Answers</button> <!-- Unique ID -->
                        <button class="btn btn-secondary" id="reveal-crossword-solution">Reveal Solution</button> <!-- Unique ID -->
                        <button class="btn btn-accent" id="new-crossword-game">New Crossword</button> <!-- Unique ID -->
                         <select id="tier-filter-crossword" class="btn btn-secondary"> <!-- Unique ID, though less impactful here -->
                            <option value="all">All Tiers (Uses defined layout)</option>
                        </select>
                    </div>
                    
                    <div id="crossword-message-display" style="margin-top: 1rem; text-align: center; font-weight: bold;"></div> <!-- Unique ID -->
                </div>
            </div>
        </section>
        
        <!-- Pictionary Section -->
        <section id="pictionary" class="section">
            <h2 class="section-title">Electromagnet Pictionary</h2>
            <div class="card">
                <p>Draw the electromagnet term on your mini-whiteboard (or paper!) for others to guess. The definition is provided for clarity.</p>
                
                <div class="pictionary-container">
                    <div class="pictionary-word-display" id="pictionary-word-term">Term</div> <!-- Unique ID -->
                    <div class="pictionary-image" id="pictionary-image-display">🖼️</div> <!-- Unique ID and icon -->
                    <div class="pictionary-definition-display" id="pictionary-word-definition">Definition for the term.</div> <!-- Unique ID -->
                    
                    <div class="pictionary-instructions" style="margin: 1.5rem 0; padding: 1rem; background-color: #E0F7FA; border-left: 4px solid var(--secondary); border-radius: 8px;">
                        <h4 style="margin-bottom: 0.5rem; color: var(--primary-dark);">How to Play (Offline):</h4>
                        <ol style="padding-left: 1.5rem;">
                            <li>One person (the "drawer") uses the controls below to get a random term.</li>
                            <li>The drawer silently reads the term and its definition. The icon might give drawing ideas!</li>
                            <li>The drawer has 60 seconds (use the timer!) to draw the term. No words or letters!</li>
                            <li>Other players try to guess the term.</li>
                            <li>Award points as you see fit (e.g., 1 point for correct guess, bonus for definition).</li>
                        </ol>
                    </div>
                    
                    <div class="pictionary-controls" style="display: flex; justify-content: center; gap: 0.5rem; margin-top: 1rem; flex-wrap: wrap;">
                        <button class="btn" id="prev-pictionary-word">Previous</button> <!-- Unique ID -->
                        <button class="btn" id="next-pictionary-word">Next</button> <!-- Unique ID -->
                        <button class="btn btn-accent" id="random-pictionary-word">Random Word</button> <!-- Unique ID -->
                        <select id="tier-filter-pictionary" class="btn btn-secondary"> <!-- Unique ID -->
                            <option value="all">All Tiers</option>
                            <option value="1">Tier 1 Only</option>
                        </select>
                    </div>
                    
                    <div class="timer-container" style="margin-top: 2rem; text-align: center;">
                        <div class="timer-display" id="pictionary-timer-display" style="font-size: 2rem; font-weight: bold;">60</div> <!-- Unique ID -->
                        <div class="timer-controls" style="margin-top: 0.5rem;">
                            <button class="btn" id="start-pictionary-timer">Start Timer</button> <!-- Unique ID -->
                            <button class="btn btn-secondary" id="reset-pictionary-timer">Reset</button> <!-- Unique ID -->
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Hangman Section -->
        <section id="hangman" class="section">
            <h2 class="section-title">Electromagnet Hangman</h2>
            <div class="card">
                <p>Guess the electromagnet term one letter at a time. After revealing the word, choose the correct definition to score a point!</p>
                
                <div class="hangman-container">
                    <div class="hangman-drawing">
                        <svg id="hangman-svg-figure" viewBox="0 0 300 300" width="200" height="200"> <!-- Unique ID -->
                            <line x1="20" y1="280" x2="100" y2="280" stroke="#000" stroke-width="3" />
                            <line x1="60" y1="20" x2="60" y2="280" stroke="#000" stroke-width="3" />
                            <line x1="60" y1="20" x2="140" y2="20" stroke="#000" stroke-width="3" />
                            <line x1="140" y1="20" x2="140" y2="50" stroke="#000" stroke-width="3" />
                            <g id="hangman-parts-figure" style="display: none;"> <!-- Unique ID -->
                                <circle id="hangman-head" cx="140" cy="80" r="30" stroke="#000" fill="none" stroke-width="3" style="display: none;" />
                                <line id="hangman-body" x1="140" y1="110" x2="140" y2="200" stroke="#000" stroke-width="3" style="display: none;" />
                                <line id="hangman-left-arm" x1="140" y1="120" x2="100" y2="160" stroke="#000" stroke-width="3" style="display: none;" />
                                <line id="hangman-right-arm" x1="140" y1="120" x2="180" y2="160" stroke="#000" stroke-width="3" style="display: none;" />
                                <line id="hangman-left-leg" x1="140" y1="200" x2="100" y2="250" stroke="#000" stroke-width="3" style="display: none;" />
                                <line id="hangman-right-leg" x1="140" y1="200" x2="180" y2="250" stroke="#000" stroke-width="3" style="display: none;" />
                            </g>
                        </svg>
                    </div>
                    
                    <div class="hangman-word-container">
                        <div id="hangman-word-display" class="hangman-word"> <!-- Unique ID -->
                        </div>
                        <div id="hangman-keyboard-area" class="hangman-keyboard"> <!-- Unique ID -->
                        </div>
                    </div>
                </div>
                
                <div id="hangman-definition-choice-container" class="hangman-definition-container" style="display: none;"> <!-- Unique ID -->
                    <h4>Choose the correct definition:</h4>
                    <div id="hangman-definition-options" class="hangman-definitions"> <!-- Unique ID -->
                    </div>
                </div>
                
                <div class="hangman-controls">
                    <div class="hangman-score">Score: <span id="hangman-current-score">0</span></div> <!-- Unique ID -->
                    <div class="hangman-status" id="hangman-game-status">Let's play! Guess a letter.</div> <!-- Unique ID -->
                    <button class="btn" id="new-hangman-game-word">New Word</button> <!-- Unique ID -->
                    <select id="tier-filter-hangman" class="btn btn-secondary"> <!-- Unique ID -->
                        <option value="all">All Tiers</option>
                        <option value="1">Tier 1 Only</option>
                    </select>
                </div>
            </div>
        </section>
    </div>
    
    <footer>
        <p>Electromagnets Key Terms Revision Hub &copy; 2024 | KS3 Physics Resource</p>
    </footer>
    
    <script>
        // Electromagnet terms data
        const electromagnetTerms = [
            { term: 'Attract', definition: 'To pull objects towards each other (e.g. opposite magnetic poles attract).', tier: 1 },
            { term: 'Repel', definition: 'To push objects away from each other (e.g. like magnetic poles repel).', tier: 1 },
            { term: 'Magnet', definition: 'An object that produces a magnetic field and has a north and south pole.', tier: 1 },
            { term: 'Magnetic Pole', definition: 'The ends of a magnet where the magnetic force is strongest (north and south).', tier: 1 },
            { term: 'Magnetic Material', definition: 'A material that can be attracted by a magnet (e.g. iron, nickel, cobalt).', tier: 1 },
            { term: 'Magnetic Field', definition: 'The invisible area around a magnet where magnetic forces can act.', tier: 1 },
            { term: 'Magnetic Field Lines', definition: 'Lines that show the direction and strength of a magnetic field (from north to south).', tier: 1 },
            { term: 'Permanent Magnet', definition: 'A magnet that produces its own magnetic field all the time.', tier: 1 },
            { term: 'Electromagnet', definition: 'A magnet made by passing an electric current through a coil of wire.', tier: 1 },
            { term: 'Core', definition: 'The magnetic material inside the coil of an electromagnet (usually iron).', tier: 1 },
            { term: 'Electric Bell', definition: 'A device that uses an electromagnet to repeatedly make and break a circuit, causing a bell to ring.', tier: 1 },
            { term: 'Circuit Breaker', definition: 'A safety device that uses an electromagnet to break a circuit if the current gets too high.', tier: 1 },
            { term: 'Loudspeaker', definition: 'A device that uses an electromagnet and cone to turn electric signals into sound.', tier: 1 },
            { term: 'Iron', definition: 'A common ferromagnetic material, excellent for electromagnet cores.', tier: 1 },
            { term: 'Pole', definition: 'An end of a magnet (North or South) where magnetic force is strongest. (Short form of Magnetic Pole)', tier: 1 },
            { term: 'Bell', definition: 'Common term for Electric Bell, a device using an electromagnet to make sound.', tier: 1 }
        ];
        
        // Wrong definitions for Beat the Physicist game (must match length of electromagnetTerms)
        const wrongDefinitions = [
            'To push objects away from each other.', // Attract
            'To pull objects towards each other.', // Repel
            'Any piece of metal that conducts electricity.', // Magnet
            'The exact center of a magnet where the force is weakest.', // Magnetic Pole
            'A material that repels all magnets and cannot be magnetized.', // Magnetic Material
            'The visible colorful lines seen around a magnet using special glasses.', // Magnetic Field
            'Lines that travel from the south pole to the north pole of a magnet.', // Magnetic Field Lines
            'A magnet that only works when electricity is supplied to it.', // Permanent Magnet
            'A type of naturally occurring magnetic rock, also known as lodestone.', // Electromagnet
            'The outer insulating casing of an electromagnet coil.', // Core
            'A device that uses static electricity and a vibrating plate to make a sound.', // Electric Bell
            'A device that increases the current in a circuit when it gets too low.', // Circuit Breaker
            'A device that converts sound waves into electrical signals for recording.', // Loudspeaker
            'A material that cannot be magnetized and repels magnetic fields.', // Iron
            'The geometric center point of any magnetized object.', // Pole
            'A musical instrument that uses magnetism to create tones without electricity.' // Bell
        ];
        
        // Icons for pictionary
        const pictionaryIcons = [
            'N→←S', // Attract
            'N←→N', // Repel
            '🧲', // Magnet
            'N···S', // Magnetic Pole
            '🔩🔗📎', // Magnetic Material (nuts, chains, paperclips)
            '(((🧲)))', // Magnetic Field
            'N↷S', // Magnetic Field Lines
            '🧱(N S)', // Permanent Magnet (brick with N S)
            '🔋+🌀=🧲', // Electromagnet (Battery + Coil = Magnet)
            '🔩(🌀)', // Core (Bolt in coil)
            '🔔⚡🔨', // Electric Bell (Bell, electricity, hammer)
            '⚡🛡️🔌', // Circuit Breaker (Lightning, shield, plug)
            '🔊🎶', // Loudspeaker
            'Fe', // Iron
            'N/S', // Pole
            '🛎️', // Bell
        ];

        const masterTermList = electromagnetTerms; // Main list to use throughout
        
        // Navigation functionality
        document.querySelectorAll('.nav-btn').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.section').forEach(section => section.classList.remove('active'));
                button.classList.add('active');
                const sectionId = button.getAttribute('data-section');
                document.getElementById(sectionId).classList.add('active');
            });
        });
        
        // Dark theme toggle (kept for now, can be removed if not desired)
        const themeToggle = document.getElementById('theme-toggle');
        if (themeToggle) {
            themeToggle.addEventListener('change', function() {
                document.body.classList.toggle('dark-theme'); // Assumes a .dark-theme class for CSS
            });
        }
        
        // Utility function to filter terms by tier
        function filterTermsByTier(tier, termList = masterTermList) {
            if (tier === 'all') {
                return termList;
            } else {
                return termList.filter(term => term.tier === parseInt(tier));
            }
        }
        
        // Utility function to shuffle an array
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Populate Home Page Word Grid
        (function() {
            const homeWordGrid = document.getElementById('home-word-grid');
            if (homeWordGrid) {
                masterTermList.forEach(termData => {
                    const card = document.createElement('div');
                    card.classList.add('word-card');
                    card.innerHTML = `
                        <div class="word-term">
                            <span class="tier-badge tier-${termData.tier}">Tier ${termData.tier}</span>${termData.term}
                        </div>
                        <div class="word-definition">${termData.definition}</div>
                    `;
                    homeWordGrid.appendChild(card);
                });
            }
        })();
        
        // Flashcards functionality
        (function() {
            const flashcardSection = document.getElementById('flashcards');
            if (!flashcardSection) return;

            let currentCardIndex = 0;
            let filteredCards = [...masterTermList];
            const flashcardEl = flashcardSection.querySelector('.flashcard');
            const frontEl = flashcardSection.querySelector('.flashcard-front');
            const backEl = flashcardSection.querySelector('.flashcard-back');
            const prevBtn = flashcardSection.querySelector('#prev-card');
            const nextBtn = flashcardSection.querySelector('#next-card');
            const tierFilter = flashcardSection.querySelector('#tier-filter-flashcards');
            const shuffleBtn = flashcardSection.querySelector('#shuffle-cards');
            
            function updateCard() {
                if (!flashcardEl || filteredCards.length === 0) {
                    if(frontEl) frontEl.innerHTML = 'No terms available. <div class="flashcard-tier"></div>';
                    if(backEl) backEl.textContent = 'Please adjust filter or add terms.';
                    return;
                }
                
                const card = filteredCards[currentCardIndex];
                frontEl.innerHTML = `${card.term} <div class="flashcard-tier"><span class="tier-badge tier-${card.tier}">Tier ${card.tier}</span></div>`;
                backEl.textContent = card.definition;
                flashcardEl.classList.remove('flipped');
            }

            if(flashcardEl) flashcardEl.addEventListener('click', () => flashcardEl.classList.toggle('flipped'));
            if(prevBtn) prevBtn.addEventListener('click', () => {
                if (filteredCards.length === 0) return;
                currentCardIndex = (currentCardIndex - 1 + filteredCards.length) % filteredCards.length;
                updateCard();
            });
            if(nextBtn) nextBtn.addEventListener('click', () => {
                if (filteredCards.length === 0) return;
                currentCardIndex = (currentCardIndex + 1) % filteredCards.length;
                updateCard();
            });
            if(tierFilter) tierFilter.addEventListener('change', () => {
                filteredCards = filterTermsByTier(tierFilter.value);
                currentCardIndex = 0;
                updateCard();
            });
            if(shuffleBtn) shuffleBtn.addEventListener('click', () => {
                filteredCards = shuffleArray(filteredCards);
                currentCardIndex = 0;
                updateCard();
            });
            
            updateCard(); // Initial call
        })();
        
        // Matching Game functionality
        (function() {
            const matchingSection = document.getElementById('matching');
            if (!matchingSection) return;

            const termsColumn = matchingSection.querySelector('#terms-column');
            const definitionsColumn = matchingSection.querySelector('#definitions-column');
            const resetBtn = matchingSection.querySelector('#reset-matching');
            const tierFilter = matchingSection.querySelector('#tier-filter-matching');
            
            let selectedTerm = null;
            let filteredTerms = [...masterTermList];
            
            function initMatchingGame() {
                termsColumn.innerHTML = '';
                definitionsColumn.innerHTML = '';
                selectedTerm = null;
                
                const currentFilteredTerms = filterTermsByTier(tierFilter.value);
                if (currentFilteredTerms.length === 0) {
                    termsColumn.innerHTML = '<div class="matching-item">No terms available.</div>';
                    return;
                }
                
                const gameTerms = shuffleArray(currentFilteredTerms).slice(0, Math.min(8, currentFilteredTerms.length));
                const shuffledDefinitions = shuffleArray([...gameTerms]);
                
                gameTerms.forEach(term => {
                    const termEl = document.createElement('div');
                    termEl.classList.add('matching-item');
                    termEl.textContent = term.term;
                    termEl.dataset.term = term.term;
                    termEl.addEventListener('click', () => handleTermClick(termEl, term));
                    termsColumn.appendChild(termEl);
                });
                
                shuffledDefinitions.forEach(term => {
                    const defEl = document.createElement('div');
                    defEl.classList.add('matching-item');
                    defEl.textContent = term.definition;
                    defEl.dataset.term = term.term;
                    defEl.addEventListener('click', () => handleDefinitionClick(defEl));
                    definitionsColumn.appendChild(defEl);
                });
            }

            function handleTermClick(termEl, term) {
                if (termEl.classList.contains('matched')) return;
                document.querySelectorAll('#terms-column .matching-item.selected').forEach(item => item.classList.remove('selected'));
                termEl.classList.add('selected');
                selectedTerm = term;
            }

            function handleDefinitionClick(defEl) {
                if (defEl.classList.contains('matched') || !selectedTerm) return;
                
                if (defEl.dataset.term === selectedTerm.term) {
                    defEl.classList.add('matched');
                    termsColumn.querySelector(`.matching-item[data-term="${selectedTerm.term}"]`).classList.add('matched');
                    selectedTerm = null;
                    if (document.querySelectorAll('#terms-column .matching-item:not(.matched)').length === 0) {
                        setTimeout(() => alert('Congratulations! All matched!'), 300);
                    }
                } else {
                    defEl.classList.add('selected');
                    defEl.style.backgroundColor = 'var(--error)';
                    setTimeout(() => {
                        defEl.classList.remove('selected');
                        defEl.style.backgroundColor = '';
                        if (selectedTerm) { // only deselect term if still selected (i.e. user didn't click another term)
                           const stillSelectedTermEl = termsColumn.querySelector(`.matching-item[data-term="${selectedTerm.term}"].selected`);
                           if(stillSelectedTermEl) stillSelectedTermEl.classList.remove('selected');
                        }
                        selectedTerm = null;
                    }, 1000);
                }
            }
            
            if(resetBtn) resetBtn.addEventListener('click', initMatchingGame);
            if(tierFilter) tierFilter.addEventListener('change', initMatchingGame);
            initMatchingGame();
        })();
        
        // Splat Game functionality
        (function() {
            const splatSection = document.getElementById('splat');
            if (!splatSection) return;

            const splatBoard = splatSection.querySelector('#splat-board');
            const splatDefinitionEl = splatSection.querySelector('#splat-definition');
            const nextBtn = splatSection.querySelector('#next-splat');
            const resetBtn = splatSection.querySelector('#reset-splat-scores');
            const tierFilter = splatSection.querySelector('#tier-filter-splat');
            const player1ScoreEl = splatSection.querySelector('#player1-score');
            const player2ScoreEl = splatSection.querySelector('#player2-score');
            
            let currentCorrectTerm = null;
            let scores = { player1: 0, player2: 0 };
            let playerNames = { player1: "Player 1", player2: "Player 2" };
            
            function initSplatGame() {
                splatBoard.innerHTML = '';
                const currentFilteredTerms = filterTermsByTier(tierFilter.value);

                if (currentFilteredTerms.length < 4) {
                    splatDefinitionEl.textContent = 'Not enough terms for this tier.';
                    return;
                }
                
                const gameTerms = shuffleArray(currentFilteredTerms).slice(0, 4);
                currentCorrectTerm = gameTerms[0];
                splatDefinitionEl.textContent = currentCorrectTerm.definition;
                
                shuffleArray(gameTerms).forEach(term => { // Shuffle display order
                    const wordEl = document.createElement('div');
                    wordEl.classList.add('splat-word');
                    wordEl.textContent = term.term;
                    wordEl.addEventListener('click', () => handleSplatClick(wordEl, term));
                    splatBoard.appendChild(wordEl);
                });
            }

            function handleSplatClick(wordEl, term) {
                document.querySelectorAll('#splat-board .splat-word').forEach(el => el.style.pointerEvents = 'none'); // Disable further clicks
                if (term.term === currentCorrectTerm.term) {
                    wordEl.style.backgroundColor = 'var(--success)';
                    wordEl.style.color = 'white';
                    // Simple alert for now, original scoring dialog was complex
                    const winner = prompt(`Correct! Which player got it? (${playerNames.player1} or ${playerNames.player2}) Enter 1 or 2, or leave blank for no point.`);
                    if (winner === '1') scores.player1++;
                    else if (winner === '2') scores.player2++;
                    updateScores();
                } else {
                    wordEl.style.backgroundColor = 'var(--error)';
                    wordEl.style.color = 'white';
                    // Highlight correct one
                    splatBoard.querySelectorAll('.splat-word').forEach(el => {
                        if(el.textContent === currentCorrectTerm.term) {
                            el.style.backgroundColor = 'var(--success)';
                            el.style.color = 'white';
                        }
                    });
                }
            }

            function updateScores() {
                player1ScoreEl.textContent = `${playerNames.player1}: ${scores.player1}`;
                player2ScoreEl.textContent = `${playerNames.player2}: ${scores.player2}`;
            }
            
            if(nextBtn) nextBtn.addEventListener('click', initSplatGame);
            if(resetBtn) resetBtn.addEventListener('click', () => {
                scores = { player1: 0, player2: 0 };
                updateScores();
                initSplatGame();
            });
            if(tierFilter) tierFilter.addEventListener('change', initSplatGame);
            
            // Get player names once
            const p1Name = prompt("Enter name for Player 1 (Splat Game):", "Player 1");
            if (p1Name) playerNames.player1 = p1Name;
            const p2Name = prompt("Enter name for Player 2 (Splat Game):", "Player 2");
            if (p2Name) playerNames.player2 = p2Name;
            updateScores();
            initSplatGame();
        })();
        
        // Beat the Physicist functionality
        (function() {
            const physicistSection = document.getElementById('physicist');
            if (!physicistSection) return;

            const termDisplay = physicistSection.querySelector('#physicist-term-display');
            const definitionDisplay = physicistSection.querySelector('#physicist-definition-display');
            const correctBtn = physicistSection.querySelector('#physicist-correct-btn');
            const incorrectBtn = physicistSection.querySelector('#physicist-incorrect-btn');
            const feedbackEl = physicistSection.querySelector('#physicist-feedback');
            const nextBtn = physicistSection.querySelector('#next-physicist-q');
            const scoreEl = physicistSection.querySelector('#physicist-score-display');
            
            let currentTermData = null;
            let isDefinitionActuallyCorrect = false;
            let score = 0;
            
            function newPhysicistQuestion() {
                const terms = masterTermList;
                if (terms.length === 0) {
                    termDisplay.textContent = "No terms";
                    definitionDisplay.textContent = "N/A";
                    return;
                }
                currentTermData = terms[Math.floor(Math.random() * terms.length)];
                
                isDefinitionActuallyCorrect = Math.random() < 0.5;
                
                termDisplay.textContent = currentTermData.term;
                if (isDefinitionActuallyCorrect) {
                    definitionDisplay.textContent = currentTermData.definition;
                } else {
                    // Find the index of currentTermData to get corresponding wrongDefinition
                    const termIndex = masterTermList.findIndex(t => t.term === currentTermData.term);
                    if (wrongDefinitions[termIndex]) {
                         definitionDisplay.textContent = wrongDefinitions[termIndex];
                    } else { // Fallback if wrongDefinitions is not perfectly aligned
                         definitionDisplay.textContent = "A completely random and incorrect statement about physics.";
                    }
                }
                
                feedbackEl.style.display = 'none';
                correctBtn.disabled = false;
                incorrectBtn.disabled = false;
            }

            function handleAnswer(userThinksIsCorrect) {
                correctBtn.disabled = true;
                incorrectBtn.disabled = true;
                feedbackEl.style.display = 'block';

                if (userThinksIsCorrect === isDefinitionActuallyCorrect) {
                    feedbackEl.innerHTML = `<strong style="color: var(--success);">You're right!</strong>`;
                    if (isDefinitionActuallyCorrect) {
                        feedbackEl.innerHTML += ` That definition for "${currentTermData.term}" was correct.`;
                    } else {
                        feedbackEl.innerHTML += ` That definition for "${currentTermData.term}" was indeed incorrect. The correct one is: "${currentTermData.definition}"`;
                    }
                    score++;
                } else {
                    feedbackEl.innerHTML = `<strong style="color: var(--error);">Not quite!</strong>`;
                    if (isDefinitionActuallyCorrect) {
                        feedbackEl.innerHTML += ` That definition for "${currentTermData.term}" was actually correct.`;
                    } else {
                        feedbackEl.innerHTML += ` That definition for "${currentTermData.term}" was incorrect. The correct one is: "${currentTermData.definition}"`;
                    }
                }
                scoreEl.textContent = `Score: ${score}`;
            }
            
            if(correctBtn) correctBtn.addEventListener('click', () => handleAnswer(true));
            if(incorrectBtn) incorrectBtn.addEventListener('click', () => handleAnswer(false));
            if(nextBtn) nextBtn.addEventListener('click', newPhysicistQuestion);
            
            newPhysicistQuestion();
        })();

        // Pairs Game functionality
        (function() {
            const pairsSection = document.getElementById('pairs');
            if (!pairsSection) return;

            const pairsBoard = pairsSection.querySelector('#pairs-board');
            const resetBtn = pairsSection.querySelector('#reset-pairs-game');
            const tierFilter = pairsSection.querySelector('#tier-filter-pairs');
            const movesEl = pairsSection.querySelector('#pairs-moves-display');
            
            let moves = 0;
            let firstCard = null, secondCard = null;
            let lockBoard = false;
            
            function initPairsGame() {
                pairsBoard.innerHTML = '';
                moves = 0;
                updateMovesDisplay();
                firstCard = null; secondCard = null; lockBoard = false;

                const currentFilteredTerms = filterTermsByTier(tierFilter.value);
                if (currentFilteredTerms.length < 2) { // Need at least 2 terms for 4 cards
                    pairsBoard.innerHTML = '<p style="grid-column: 1 / -1; text-align: center;">Not enough terms for this tier. Select at least 2 terms.</p>';
                    return;
                }
                
                const gameTerms = shuffleArray(currentFilteredTerms).slice(0, Math.min(8, currentFilteredTerms.length)); // Max 8 pairs = 16 cards
                 if (gameTerms.length < 2) { // check again after slice
                    pairsBoard.innerHTML = '<p style="grid-column: 1 / -1; text-align: center;">Not enough terms to form pairs (need at least 2).</p>';
                    return;
                }

                const pairs = [];
                gameTerms.forEach(term => {
                    pairs.push({ content: term.term, type: 'term', matchId: term.term });
                    pairs.push({ content: term.definition, type: 'definition', matchId: term.term });
                });
                
                // Adjust grid columns based on number of pairs
                const numPairs = gameTerms.length;
                let columns = 4; // Default
                if (numPairs <= 2) columns = 2;
                else if (numPairs <= 4) columns = 4; // For 3 or 4 pairs
                else if (numPairs <= 6) columns = 4; // For 5 or 6 pairs (12 cards)
                else columns = 4; // For 7 or 8 pairs (16 cards) - could be 4x4
                pairsBoard.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;


                shuffleArray(pairs).forEach(pairData => {
                    const card = document.createElement('div');
                    card.classList.add('pair-card');
                    card.dataset.matchId = pairData.matchId;
                    card.innerHTML = `
                        <div class="pair-card-inner">
                            <div class="pair-card-front">?</div>
                            <div class="pair-card-back">${pairData.content}</div>
                        </div>
                    `;
                    card.addEventListener('click', () => flipCard(card));
                    pairsBoard.appendChild(card);
                });
            }

            function flipCard(card) {
                if (lockBoard || card.classList.contains('flipped') || card.classList.contains('matched')) return;
                card.classList.add('flipped');

                if (!firstCard) {
                    firstCard = card;
                    return;
                }
                secondCard = card;
                moves++;
                updateMovesDisplay();
                lockBoard = true;
                checkForMatch();
            }

            function checkForMatch() {
                if (firstCard.dataset.matchId === secondCard.dataset.matchId) {
                    firstCard.classList.add('matched');
                    secondCard.classList.add('matched');
                    resetTurn();
                    if (document.querySelectorAll('.pair-card:not(.matched)').length === 0) {
                        setTimeout(() => alert(`Congratulations! You found all pairs in ${moves} moves!`), 500);
                    }
                } else {
                    setTimeout(() => {
                        firstCard.classList.remove('flipped');
                        secondCard.classList.remove('flipped');
                        resetTurn();
                    }, 1200);
                }
            }
            function resetTurn() {
                firstCard = null; secondCard = null; lockBoard = false;
            }
            function updateMovesDisplay() { movesEl.textContent = `Moves: ${moves}`; }
            
            if(resetBtn) resetBtn.addEventListener('click', initPairsGame);
            if(tierFilter) tierFilter.addEventListener('change', initPairsGame);
            initPairsGame();
        })();
        
        // Word Search functionality
        (function() {
            const wordSearchSection = document.getElementById('wordsearch');
            if (!wordSearchSection) return;

            const gridEl = wordSearchSection.querySelector('#word-search-grid');
            const listEl = wordSearchSection.querySelector('#word-search-word-list');
            const newGameBtn = wordSearchSection.querySelector('#new-word-search-game');
            const tierFilter = wordSearchSection.querySelector('#tier-filter-wordsearch');
            
            const gridSize = 15; // Standard 15x15 grid
            let wordsToFind = [];
            let grid = [];
            let selectedCells = [];
            let isSelecting = false;

            function generateWordSearch() {
                gridEl.innerHTML = '';
                listEl.innerHTML = '';
                wordsToFind = [];
                grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(''));

                const currentFilteredTerms = filterTermsByTier(tierFilter.value);
                 if (currentFilteredTerms.length < 3) {
                    gridEl.innerHTML = '<p style="grid-column: 1 / -1; text-align: center;">Not enough terms (need at least 3) for this tier to create a word search.</p>';
                    return;
                }

                const termsForSearch = shuffleArray(currentFilteredTerms)
                    .map(t => t.term.toUpperCase().replace(/[^A-Z]/g, '')) // Clean words
                    .filter(w => w.length > 2 && w.length <= gridSize) // Filter by length
                    .slice(0, Math.min(8, currentFilteredTerms.length)); // Max 8 words

                if (termsForSearch.length < 1) {
                    gridEl.innerHTML = '<p style="grid-column: 1 / -1; text-align: center;">Could not find suitable words for the search.</p>';
                    return;
                }

                wordsToFind = termsForSearch.map(word => ({ text: word, found: false }));

                // Place words
                wordsToFind.forEach(wordObj => placeWord(wordObj.text));

                // Fill empty cells
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (grid[r][c] === '') {
                            grid[r][c] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
                        }
                        const cell = document.createElement('div');
                        cell.classList.add('word-search-cell');
                        cell.textContent = grid[r][c];
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        cell.addEventListener('mousedown', handleMouseDown);
                        cell.addEventListener('mouseover', handleMouseOver);
                        gridEl.appendChild(cell);
                    }
                }
                 window.addEventListener('mouseup', handleMouseUp); // Add once

                // Display word list
                wordsToFind.forEach(wordObj => {
                    const li = document.createElement('div');
                    li.classList.add('word-search-word');
                    li.textContent = wordObj.text;
                    li.dataset.word = wordObj.text;
                    listEl.appendChild(li);
                });
            }

            function placeWord(word) {
                const directions = [
                    { dr: 0, dc: 1 },  // Horizontal
                    { dr: 1, dc: 0 },  // Vertical
                    { dr: 1, dc: 1 },  // Diagonal down-right
                    { dr: 1, dc: -1} // Diagonal down-left (ensure col doesn't go <0)
                ];
                let placed = false;
                for (let attempts = 0; attempts < 100 && !placed; attempts++) {
                    const dir = directions[Math.floor(Math.random() * directions.length)];
                    const rStart = Math.floor(Math.random() * gridSize);
                    const cStart = Math.floor(Math.random() * gridSize);

                    let r = rStart, c = cStart;
                    let fits = true;
                    for (let i = 0; i < word.length; i++) {
                        if (r < 0 || r >= gridSize || c < 0 || c >= gridSize || (grid[r][c] !== '' && grid[r][c] !== word[i])) {
                            fits = false;
                            break;
                        }
                        r += dir.dr;
                        c += dir.dc;
                    }

                    if (fits) {
                        r = rStart; c = cStart;
                        for (let i = 0; i < word.length; i++) {
                            grid[r][c] = word[i];
                            r += dir.dr;
                            c += dir.dc;
                        }
                        placed = true;
                    }
                }
            }

            function handleMouseDown(e) {
                isSelecting = true;
                selectedCells = [e.target];
                e.target.classList.add('selected');
            }
            function handleMouseOver(e) {
                if (isSelecting && !selectedCells.includes(e.target)) {
                    // Basic selection: just add to list. Complex line drawing is harder.
                    // For simplicity, we'll just let user select cells, and check on mouseup.
                    // A more robust solution would check if the new cell forms a line with previous.
                     selectedCells.push(e.target);
                     e.target.classList.add('selected');
                }
            }
            function handleMouseUp() {
                if (!isSelecting || selectedCells.length === 0) return;
                isSelecting = false;
                
                const selectedWord = selectedCells.map(cell => cell.textContent).join('');
                const selectedWordReversed = selectedWord.split('').reverse().join('');

                const foundWordObj = wordsToFind.find(w => !w.found && (w.text === selectedWord || w.text === selectedWordReversed));

                if (foundWordObj) {
                    foundWordObj.found = true;
                    selectedCells.forEach(cell => cell.classList.add('found'));
                    listEl.querySelector(`.word-search-word[data-word="${foundWordObj.text}"]`).classList.add('found');
                    if (wordsToFind.every(w => w.found)) {
                        setTimeout(() => alert('Well Done! You found all the words!'), 300);
                    }
                } else {
                    selectedCells.forEach(cell => cell.classList.remove('selected'));
                }
                selectedCells = [];
            }

            if(newGameBtn) newGameBtn.addEventListener('click', generateWordSearch);
            if(tierFilter) tierFilter.addEventListener('change', generateWordSearch);
            generateWordSearch();
        })();

        // Crossword Game functionality
        (function() {
            const crosswordSection = document.getElementById('crossword');
            if (!crosswordSection) return;

            const gridDisplay = crosswordSection.querySelector('#crossword-grid-display');
            const acrossCluesDisplay = crosswordSection.querySelector('#across-clues-display');
            const downCluesDisplay = crosswordSection.querySelector('#down-clues-display');
            const checkBtn = crosswordSection.querySelector('#check-crossword-answers');
            const revealBtn = crosswordSection.querySelector('#reveal-crossword-solution');
            const newBtn = crosswordSection.querySelector('#new-crossword-game');
            const messageDisplay = crosswordSection.querySelector('#crossword-message-display');
            const activeCellInput = crosswordSection.querySelector('#crossword-active-cell-input'); // The actual input element
            // Tier filter for crossword is less functional as layouts are predefined
            // const tierFilter = crosswordSection.querySelector('#tier-filter-crossword');

            let currentCrosswordData = null;
            let currentLayoutIndex = 0; // To cycle through predefined layouts
            let selectedCellElement = null; // The div element
            let currentDirection = 'across';

            // Define layouts directly here (or move CrosswordManager logic here)
            const electromagnetCrosswordLayouts = [
                {
                    size: 10,
                    words: [ // word should be the cleaned, uppercase version from electromagnetTerms
                        { word: "MAGNET", row: 1, col: 0, direction: "across", clueNum: 1 },
                        { word: "REPEL", row: 3, col: 3, direction: "across", clueNum: 2 },
                        { word: "CORE", row: 5, col: 0, direction: "across", clueNum: 3 },
                        { word: "IRON", row: 7, col: 2, direction: "across", clueNum: 4 },
                        { word: "ATTRACT", row: 0, col: 2, direction: "down", clueNum: 5 },
                        { word: "POLE", row: 3, col: 0, direction: "down", clueNum: 6 },
                        { word: "BELL", row: 0, col: 6, direction: "down", clueNum: 7 }
                    ]
                },
                // Add another layout if desired
                {
                    size: 10,
                    words: [
                        { word: "FIELD", row: 0, col: 3, direction: "across", clueNum: 1 }, // Using FIELD from Magnetic Field
                        { word: "ELECTROMAGNET", row: 5, col: 0, direction: "across", clueNum: 2}, // This one is too long for 10x10 unless other words are very short or it's the only one. Let's remove.
                        { word: "PERMANENTMAGNET", row: 8, col: 0, direction: "across", clueNum: 3}, // Also too long.
                        // Simpler words for a second layout
                        { word: "SOUTH", row: 2, col: 1, direction: "across", clueNum: 2}, // Add SOUTH & NORTH to terms for variety
                        { word: "NORTH", row: 4, col: 4, direction: "across", clueNum: 3},
                        { word: "CURRENT", row: 6, col: 0, direction: "across", clueNum: 4}, // Add CURRENT
                        { word: "LINES", row: 0, col: 0, direction: "down", clueNum: 5 }, // From Field Lines
                        { word: "SWITCH", row: 1, col: 6, direction: "down", clueNum: 6 }, // Add SWITCH
                    ]
                }
            ];
            // Add new terms for second crossword layout to masterTermList or handle them as special cases.
            // For simplicity, I'll assume the first layout. For a production app, these terms would be in masterTermList.
            // Let's stick to layout 0 for this example to avoid adding too many specific terms to masterTermList.
             currentLayoutIndex = 0; // Force first layout.

            function getTermDefinition(wordKey) {
                const cleanedKey = wordKey.toUpperCase().replace(/[^A-Z]/g, '');
                const termData = masterTermList.find(t => t.term.toUpperCase().replace(/[^A-Z]/g, '') === cleanedKey);
                return termData ? termData.definition : `Definition for ${wordKey}`;
            }
            
            function generateCrosswordGrid(layout) {
                const { size, words } = layout;
                const grid = Array(size).fill(null).map(() => Array(size).fill(null).map(() => ({ letter: '', isBlack: true, userInput: '', clueNum: null, isStart: false })));
                const clues = { across: [], down: [] };

                words.forEach(wordInfo => {
                    const { word, row, col, direction, clueNum } = wordInfo;
                    const definition = getTermDefinition(word);
                    clues[direction].push({ number: clueNum, text: definition, answer: word, row, col, direction });

                    for (let i = 0; i < word.length; i++) {
                        const r = direction === 'across' ? row : row + i;
                        const c = direction === 'across' ? col + i : col;
                        if (r < size && c < size) {
                            grid[r][c].letter = word[i];
                            grid[r][c].isBlack = false;
                            grid[r][c].userInput = ''; // Initialize userInput
                            if (i === 0) {
                                grid[r][c].clueNum = clueNum;
                                grid[r][c].isStart = true;
                            }
                        }
                    }
                });
                clues.across.sort((a,b) => a.number - b.number);
                clues.down.sort((a,b) => a.number - b.number);
                return { gridSize: size, grid, clues, words };
            }

            function renderCrossword() {
                if (!currentCrosswordData) return;
                const { gridSize, grid, clues } = currentCrosswordData;

                gridDisplay.innerHTML = '';
                gridDisplay.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                gridDisplay.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
                messageDisplay.textContent = '';

                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const cellData = grid[r][c];
                        const cellEl = document.createElement('div');
                        cellEl.classList.add('crossword-cell');
                        cellEl.dataset.row = r;
                        cellEl.dataset.col = c;

                        if (cellData.isBlack) {
                            cellEl.classList.add('black');
                        } else {
                            cellEl.textContent = cellData.userInput; // Display user input
                            if (cellData.clueNum) {
                                const numEl = document.createElement('span');
                                numEl.classList.add('crossword-cell-number');
                                numEl.textContent = cellData.clueNum;
                                cellEl.appendChild(numEl);
                            }
                            cellEl.addEventListener('click', handleCellClick);
                        }
                        gridDisplay.appendChild(cellEl);
                    }
                }
                renderClues(clues.across, acrossCluesDisplay);
                renderClues(clues.down, downCluesDisplay);
            }

            function renderClues(clueList, parentElement) {
                parentElement.innerHTML = '';
                clueList.forEach(clue => {
                    const clueEl = document.createElement('div');
                    clueEl.classList.add('crossword-clue');
                    clueEl.innerHTML = `<strong>${clue.number}.</strong> ${clue.text}`;
                    clueEl.dataset.number = clue.number;
                    clueEl.dataset.direction = clue.direction;
                    clueEl.addEventListener('click', () => selectClueByElement(clueEl));
                    parentElement.appendChild(clueEl);
                });
            }

            function handleCellClick(e) {
                const clickedCell = e.currentTarget;
                if (clickedCell.classList.contains('black')) return;

                const r = parseInt(clickedCell.dataset.row);
                const c = parseInt(clickedCell.dataset.col);

                if (selectedCellElement === clickedCell) { // Clicked same cell, toggle direction
                    currentDirection = currentDirection === 'across' ? 'down' : 'across';
                } else {
                    selectedCellElement = clickedCell;
                    // Default to across, or down if no across clue from this cell
                    const acrossClue = findClueForCell(r, c, 'across');
                    currentDirection = acrossClue ? 'across' : 'down';
                }
                highlightCurrentClueAndCells(r, c, currentDirection);
                positionAndFocusInput(clickedCell);
            }
            
            function selectClueByElement(clueEl) {
                const num = parseInt(clueEl.dataset.number);
                const dir = clueEl.dataset.direction;
                const clueData = currentCrosswordData.clues[dir].find(c => c.number === num);
                if (clueData) {
                    currentDirection = dir;
                    highlightCurrentClueAndCells(clueData.row, clueData.col, dir);
                    const firstCellOfClue = gridDisplay.querySelector(`.crossword-cell[data-row="${clueData.row}"][data-col="${clueData.col}"]`);
                    if (firstCellOfClue) {
                         selectedCellElement = firstCellOfClue; // Set selectedCellElement
                         positionAndFocusInput(firstCellOfClue);
                    }
                }
            }

            function findClueForCell(r, c, direction) {
                // Find which word this cell belongs to
                for (const wordInfo of currentCrosswordData.words) {
                    if (wordInfo.direction === direction) {
                        if (direction === 'across' && wordInfo.row === r && c >= wordInfo.col && c < wordInfo.col + wordInfo.answer.length) {
                            return currentCrosswordData.clues.across.find(clue => clue.number === wordInfo.clueNum);
                        }
                        if (direction === 'down' && wordInfo.col === c && r >= wordInfo.row && r < wordInfo.row + wordInfo.answer.length) {
                           return currentCrosswordData.clues.down.find(clue => clue.number === wordInfo.clueNum);
                        }
                    }
                }
                return null;
            }
            
            function highlightCurrentClueAndCells(r, c, direction) {
                // Clear previous highlights
                gridDisplay.querySelectorAll('.active, .highlighted').forEach(el => el.classList.remove('active', 'highlighted'));
                acrossCluesDisplay.querySelectorAll('.active').forEach(el => el.classList.remove('active'));
                downCluesDisplay.querySelectorAll('.active').forEach(el => el.classList.remove('active'));

                const clue = findClueForCell(r, c, direction);
                if (!clue) { // If no clue in current direction, try other direction
                    const otherDirection = direction === 'across' ? 'down' : 'across';
                    const otherClue = findClueForCell(r, c, otherDirection);
                    if (otherClue) {
                        currentDirection = otherDirection; // Switch direction
                        highlightSingleClue(otherClue);
                    } else {
                        if (selectedCellElement) selectedCellElement.classList.add('active'); // Only highlight the cell if no clue
                    }
                    return;
                }
                highlightSingleClue(clue);
            }

            function highlightSingleClue(clue) {
                 const clueListParent = clue.direction === 'across' ? acrossCluesDisplay : downCluesDisplay;
                 const clueEl = clueListParent.querySelector(`.crossword-clue[data-number="${clue.number}"][data-direction="${clue.direction}"]`);
                 if (clueEl) clueEl.classList.add('active');

                 for (let i = 0; i < clue.answer.length; i++) {
                    const rCell = clue.direction === 'across' ? clue.row : clue.row + i;
                    const cCell = clue.direction === 'across' ? clue.col + i : clue.col;
                    const cellToHighlight = gridDisplay.querySelector(`.crossword-cell[data-row="${rCell}"][data-col="${cCell}"]`);
                    if (cellToHighlight) {
                        cellToHighlight.classList.add('highlighted');
                         if (selectedCellElement && parseInt(selectedCellElement.dataset.row) === rCell && parseInt(selectedCellElement.dataset.col) === cCell) {
                            cellToHighlight.classList.add('active'); // Also mark the current cell as active
                        }
                    }
                }
                 if (selectedCellElement) selectedCellElement.classList.add('active');
            }


            function positionAndFocusInput(cellEl) {
                const cellRect = cellEl.getBoundingClientRect();
                const gridRect = gridDisplay.getBoundingClientRect();
                activeCellInput.style.left = `${cellRect.left - gridRect.left}px`;
                activeCellInput.style.top = `${cellRect.top - gridRect.top}px`;
                activeCellInput.style.width = `${cellRect.width}px`;
                activeCellInput.style.height = `${cellRect.height}px`;
                activeCellInput.style.opacity = '1'; // Make it visible for debugging, should be transparent
                activeCellInput.value = ''; // Clear previous input
                activeCellInput.focus();
            }

            activeCellInput.addEventListener('input', (e) => {
                if (!selectedCellElement) return;
                const char = e.target.value.toUpperCase();
                e.target.value = ''; // Clear input immediately

                if (char.length === 1 && char >= 'A' && char <= 'Z') {
                    selectedCellElement.childNodes[0].nodeValue = char; // Update text node, preserve number span
                    const r = parseInt(selectedCellElement.dataset.row);
                    const c = parseInt(selectedCellElement.dataset.col);
                    currentCrosswordData.grid[r][c].userInput = char;
                    moveToNextAvailableCell(r, c, currentDirection);
                }
            });
             activeCellInput.addEventListener('keydown', (e) => {
                if (e.key === 'Backspace') {
                    if (selectedCellElement) {
                        selectedCellElement.childNodes[0].nodeValue = '';
                        const r = parseInt(selectedCellElement.dataset.row);
                        const c = parseInt(selectedCellElement.dataset.col);
                        currentCrosswordData.grid[r][c].userInput = '';
                        moveToPreviousAvailableCell(r,c,currentDirection);
                    }
                    e.preventDefault();
                } else if (e.key.startsWith('Arrow')) {
                    e.preventDefault();
                    if (!selectedCellElement) return;
                    let {row: r, col: c} = selectedCellElement.dataset;
                    r = parseInt(r); c = parseInt(c);
                    if (e.key === 'ArrowUp') r--;
                    else if (e.key === 'ArrowDown') r++;
                    else if (e.key === 'ArrowLeft') c--;
                    else if (e.key === 'ArrowRight') c++;
                    
                    const nextCell = gridDisplay.querySelector(`.crossword-cell[data-row="${r}"][data-col="${c}"]:not(.black)`);
                    if (nextCell) {
                        selectedCellElement = nextCell;
                        highlightCurrentClueAndCells(r, c, currentDirection); // Re-highlight based on potentially new cell
                        positionAndFocusInput(nextCell);
                    }
                }
            });


            function moveToNextAvailableCell(r, c, direction) {
                let nextR = r, nextC = c;
                if (direction === 'across') nextC++; else nextR++;

                const clue = findClueForCell(r,c,direction);
                if (!clue || 
                    (direction === 'across' && nextC >= clue.col + clue.answer.length) ||
                    (direction === 'down' && nextR >= clue.row + clue.answer.length)) {
                    // End of word or no clue, do nothing or move to next clue
                    return;
                }

                const nextCell = gridDisplay.querySelector(`.crossword-cell[data-row="${nextR}"][data-col="${nextC}"]:not(.black)`);
                if (nextCell) {
                    selectedCellElement = nextCell; // Update selected cell
                    highlightCurrentClueAndCells(nextR, nextC, direction); // Re-highlight
                    positionAndFocusInput(nextCell);
                }
            }
            function moveToPreviousAvailableCell(r, c, direction) {
                let prevR = r, prevC = c;
                if (direction === 'across') prevC--; else prevR--;
                
                const clue = findClueForCell(r,c,direction);
                 if (!clue || 
                    (direction === 'across' && prevC < clue.col) ||
                    (direction === 'down' && prevR < clue.row)) {
                    return; // Start of word or no clue
                }

                const prevCell = gridDisplay.querySelector(`.crossword-cell[data-row="${prevR}"][data-col="${prevC}"]:not(.black)`);
                if (prevCell) {
                    selectedCellElement = prevCell;
                    highlightCurrentClueAndCells(prevR, prevC, direction);
                    positionAndFocusInput(prevCell);
                }
            }


            function checkAnswers() {
                let allCorrect = true;
                currentCrosswordData.words.forEach(wordInfo => {
                    for (let i = 0; i < wordInfo.word.length; i++) {
                        const r = wordInfo.direction === 'across' ? wordInfo.row : wordInfo.row + i;
                        const c = wordInfo.direction === 'across' ? wordInfo.col + i : wordInfo.col;
                        const cellEl = gridDisplay.querySelector(`.crossword-cell[data-row="${r}"][data-col="${c}"]`);
                        const cellData = currentCrosswordData.grid[r][c];
                        if (cellData.userInput !== cellData.letter) {
                            allCorrect = false;
                            cellEl.classList.add('incorrect');
                            cellEl.classList.remove('correct');
                        } else {
                            cellEl.classList.add('correct');
                            cellEl.classList.remove('incorrect');
                        }
                    }
                });
                messageDisplay.textContent = allCorrect ? "Congratulations! All correct!" : "Some answers are incorrect. Keep trying!";
                messageDisplay.style.color = allCorrect ? 'var(--success)' : 'var(--error)';
            }

            function revealSolution() {
                 currentCrosswordData.words.forEach(wordInfo => {
                    for (let i = 0; i < wordInfo.word.length; i++) {
                        const r = wordInfo.direction === 'across' ? wordInfo.row : wordInfo.row + i;
                        const c = wordInfo.direction === 'across' ? wordInfo.col + i : wordInfo.col;
                        const cellEl = gridDisplay.querySelector(`.crossword-cell[data-row="${r}"][data-col="${c}"]`);
                        if (cellEl && !currentCrosswordData.grid[r][c].isBlack) {
                            cellEl.childNodes[0].nodeValue = currentCrosswordData.grid[r][c].letter;
                            currentCrosswordData.grid[r][c].userInput = currentCrosswordData.grid[r][c].letter;
                            cellEl.classList.remove('incorrect');
                            cellEl.classList.add('correct');
                        }
                    }
                });
                messageDisplay.textContent = "Solution revealed!";
                messageDisplay.style.color = 'var(--primary)';
            }
            
            function initNewCrosswordGame() {
                // Cycle through layouts or implement more complex selection
                currentLayoutIndex = (currentLayoutIndex + 1) % electromagnetCrosswordLayouts.length;
                currentCrosswordData = generateCrosswordGrid(electromagnetCrosswordLayouts[currentLayoutIndex]);
                renderCrossword();
                selectedCellElement = null; // Reset selected cell
                activeCellInput.style.opacity = '0'; // Hide the floating input
            }

            if(checkBtn) checkBtn.addEventListener('click', checkAnswers);
            if(revealBtn) revealBtn.addEventListener('click', revealSolution);
            if(newBtn) newBtn.addEventListener('click', initNewCrosswordGame);
            
            // Initial game setup
            currentCrosswordData = generateCrosswordGrid(electromagnetCrosswordLayouts[currentLayoutIndex]);
            renderCrossword();
        })();
        
        // Pictionary functionality
        (function() {
            const pictionarySection = document.getElementById('pictionary');
            if (!pictionarySection) return;

            const wordTermEl = pictionarySection.querySelector('#pictionary-word-term');
            const imageDisplayEl = pictionarySection.querySelector('#pictionary-image-display');
            const wordDefinitionEl = pictionarySection.querySelector('#pictionary-word-definition');
            const prevBtn = pictionarySection.querySelector('#prev-pictionary-word');
            const nextBtn = pictionarySection.querySelector('#next-pictionary-word');
            const randomBtn = pictionarySection.querySelector('#random-pictionary-word');
            const tierFilter = pictionarySection.querySelector('#tier-filter-pictionary');
            const startTimerBtn = pictionarySection.querySelector('#start-pictionary-timer');
            const resetTimerBtn = pictionarySection.querySelector('#reset-pictionary-timer');
            const timerDisplayEl = pictionarySection.querySelector('#pictionary-timer-display');
            
            let currentIndex = 0;
            let currentFilteredTerms = [...masterTermList];
            let timerInterval = null;
            let timeLeft = 60;

            function updatePictionaryDisplay() {
                if (currentFilteredTerms.length === 0) {
                    wordTermEl.textContent = "No Terms";
                    imageDisplayEl.textContent = "❓";
                    wordDefinitionEl.textContent = "Please select a different filter.";
                    return;
                }
                const termData = currentFilteredTerms[currentIndex];
                wordTermEl.textContent = termData.term;
                wordDefinitionEl.textContent = termData.definition;
                // Find corresponding icon
                const masterIndex = masterTermList.findIndex(t => t.term === termData.term);
                imageDisplayEl.textContent = pictionaryIcons[masterIndex] || '🖼️';

                resetPictionaryTimerLogic(); // Reset timer when word changes
            }
            function resetPictionaryTimerLogic() {
                if (timerInterval) clearInterval(timerInterval);
                timeLeft = 60;
                timerDisplayEl.textContent = timeLeft;
                timerDisplayEl.style.color = 'var(--dark-text)';
                if(startTimerBtn) startTimerBtn.disabled = false;
            }

            if(prevBtn) prevBtn.addEventListener('click', () => {
                if (currentFilteredTerms.length === 0) return;
                currentIndex = (currentIndex - 1 + currentFilteredTerms.length) % currentFilteredTerms.length;
                updatePictionaryDisplay();
            });
            if(nextBtn) nextBtn.addEventListener('click', () => {
                if (currentFilteredTerms.length === 0) return;
                currentIndex = (currentIndex + 1) % currentFilteredTerms.length;
                updatePictionaryDisplay();
            });
            if(randomBtn) randomBtn.addEventListener('click', () => {
                if (currentFilteredTerms.length === 0) return;
                currentIndex = Math.floor(Math.random() * currentFilteredTerms.length);
                updatePictionaryDisplay();
            });
            if(tierFilter) tierFilter.addEventListener('change', () => {
                currentFilteredTerms = filterTermsByTier(tierFilter.value);
                currentIndex = 0;
                updatePictionaryDisplay();
            });

            if(startTimerBtn) startTimerBtn.addEventListener('click', () => {
                resetPictionaryTimerLogic(); // Ensure timer starts fresh
                startTimerBtn.disabled = true;
                timerInterval = setInterval(() => {
                    timeLeft--;
                    timerDisplayEl.textContent = timeLeft;
                    if (timeLeft <= 10) timerDisplayEl.style.color = 'var(--error)';
                    if (timeLeft <= 0) {
                        clearInterval(timerInterval);
                        timerDisplayEl.textContent = "Time's Up!";
                        timerDisplayEl.style.color = 'var(--error)';
                    }
                }, 1000);
            });
            if(resetTimerBtn) resetTimerBtn.addEventListener('click', resetPictionaryTimerLogic);
            
            updatePictionaryDisplay(); // Initial call
        })();

        // Hangman Game
        (function() {
            const hangmanSection = document.getElementById('hangman');
            if (!hangmanSection) return;

            const wordDisplayEl = hangmanSection.querySelector('#hangman-word-display');
            const keyboardAreaEl = hangmanSection.querySelector('#hangman-keyboard-area');
            const definitionChoiceContainerEl = hangmanSection.querySelector('#hangman-definition-choice-container');
            const definitionOptionsEl = hangmanSection.querySelector('#hangman-definition-options');
            const scoreDisplayEl = hangmanSection.querySelector('#hangman-current-score');
            const statusDisplayEl = hangmanSection.querySelector('#hangman-game-status');
            const newWordBtn = hangmanSection.querySelector('#new-hangman-game-word');
            const tierFilter = hangmanSection.querySelector('#tier-filter-hangman');
            const hangmanParts = {
                head: hangmanSection.querySelector('#hangman-head'),
                body: hangmanSection.querySelector('#hangman-body'),
                leftArm: hangmanSection.querySelector('#hangman-left-arm'),
                rightArm: hangmanSection.querySelector('#hangman-right-arm'),
                leftLeg: hangmanSection.querySelector('#hangman-left-leg'),
                rightLeg: hangmanSection.querySelector('#hangman-right-leg'),
                all: hangmanSection.querySelector('#hangman-parts-figure') // The <g> element
            };
            const hangmanSvgPartsOrder = ['head', 'body', 'leftArm', 'rightArm', 'leftLeg', 'rightLeg'];


            let currentWordData = null;
            let guessedWord = [];
            let wrongGuesses = 0;
            let score = 0;
            const maxWrongGuesses = 6;

            function setupNewHangmanWord() {
                wrongGuesses = 0;
                definitionChoiceContainerEl.style.display = 'none';
                definitionOptionsEl.innerHTML = '';
                statusDisplayEl.textContent = "Guess a letter!";
                statusDisplayEl.style.color = "var(--dark-text)";

                const currentFilteredTerms = filterTermsByTier(tierFilter.value);
                if (currentFilteredTerms.length === 0) {
                    wordDisplayEl.innerHTML = '<span>No terms available</span>';
                    keyboardAreaEl.innerHTML = ''; return;
                }
                currentWordData = shuffleArray(currentFilteredTerms)[0];
                const wordToGuess = currentWordData.term.toUpperCase().replace(/[^A-Z]/g, ''); // Clean word
                guessedWord = Array(wordToGuess.length).fill('_');
                
                // Reset hangman drawing
                if(hangmanParts.all) hangmanParts.all.style.display = 'none'; // Hide group first
                hangmanSvgPartsOrder.forEach(partId => {
                    if(hangmanParts[partId]) hangmanParts[partId].style.display = 'none';
                });


                renderWordDisplay();
                renderKeyboard();
            }

            function renderWordDisplay() {
                wordDisplayEl.innerHTML = guessedWord.map(letter => `<span class="hangman-letter">${letter}</span>`).join('');
            }

            function renderKeyboard() {
                keyboardAreaEl.innerHTML = '';
                const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                alphabet.split('').forEach(letter => {
                    const key = document.createElement('button');
                    key.classList.add('keyboard-key');
                    key.textContent = letter;
                    key.addEventListener('click', () => handleGuess(letter, key));
                    keyboardAreaEl.appendChild(key);
                });
            }

            function handleGuess(letter, keyElement) {
                if (keyElement.disabled || wrongGuesses >= maxWrongGuesses || guessedWord.join('') === currentWordData.term.toUpperCase().replace(/[^A-Z]/g, '')) return;
                keyElement.disabled = true;

                const wordToGuess = currentWordData.term.toUpperCase().replace(/[^A-Z]/g, '');
                let found = false;
                for (let i = 0; i < wordToGuess.length; i++) {
                    if (wordToGuess[i] === letter) {
                        guessedWord[i] = letter;
                        found = true;
                    }
                }

                if (found) {
                    keyElement.classList.add('correct');
                    renderWordDisplay();
                    if (!guessedWord.includes('_')) {
                        statusDisplayEl.textContent = "Word guessed! Now choose the definition.";
                        statusDisplayEl.style.color = "var(--success)";
                        promptForDefinition();
                    }
                } else {
                    keyElement.classList.add('wrong');
                    wrongGuesses++;
                    updateHangmanDrawing();
                    if (wrongGuesses >= maxWrongGuesses) {
                        statusDisplayEl.textContent = `Game Over! The word was: ${wordToGuess}`;
                        statusDisplayEl.style.color = "var(--error)";
                        wordDisplayEl.innerHTML = wordToGuess.split('').map(l => `<span class="hangman-letter">${l}</span>`).join('');
                    }
                }
            }
            
            function updateHangmanDrawing() {
                if (wrongGuesses > 0 && hangmanParts.all) hangmanParts.all.style.display = 'block'; // Show group
                if (wrongGuesses > 0 && hangmanParts.head) hangmanParts.head.style.display = wrongGuesses >= 1 ? 'block' : 'none';
                if (hangmanParts.body) hangmanParts.body.style.display = wrongGuesses >= 2 ? 'block' : 'none';
                if (hangmanParts.leftArm) hangmanParts.leftArm.style.display = wrongGuesses >= 3 ? 'block' : 'none';
                if (hangmanParts.rightArm) hangmanParts.rightArm.style.display = wrongGuesses >= 4 ? 'block' : 'none';
                if (hangmanParts.leftLeg) hangmanParts.leftLeg.style.display = wrongGuesses >= 5 ? 'block' : 'none';
                if (hangmanParts.rightLeg) hangmanParts.rightLeg.style.display = wrongGuesses >= 6 ? 'block' : 'none';
            }


            function promptForDefinition() {
                definitionChoiceContainerEl.style.display = 'block';
                definitionOptionsEl.innerHTML = '';
                const options = [currentWordData.definition]; // Correct definition
                
                // Get some wrong definitions (ensure they are different from correct one and each other)
                let tempWrongDefs = shuffleArray(masterTermList.filter(t => t.term !== currentWordData.term).map(t => t.definition));
                options.push(...tempWrongDefs.slice(0, 2)); // Add 2 wrong definitions
                
                shuffleArray(options).forEach(defText => {
                    const optEl = document.createElement('div');
                    optEl.classList.add('definition-option');
                    optEl.textContent = defText;
                    optEl.addEventListener('click', () => checkDefinition(defText === currentWordData.definition, optEl));
                    definitionOptionsEl.appendChild(optEl);
                });
            }

            function checkDefinition(isCorrect, optEl) {
                document.querySelectorAll('#hangman-definition-options .definition-option').forEach(el => el.style.pointerEvents = 'none');
                if (isCorrect) {
                    optEl.classList.add('correct');
                    statusDisplayEl.textContent = "Correct definition! Well done!";
                    statusDisplayEl.style.color = "var(--success)";
                    score++;
                    scoreDisplayEl.textContent = score;
                } else {
                    optEl.classList.add('incorrect');
                    statusDisplayEl.textContent = "Wrong definition. Better luck next time!";
                    statusDisplayEl.style.color = "var(--error)";
                     // Highlight correct one
                    definitionOptionsEl.querySelectorAll('.definition-option').forEach(el => {
                        if(el.textContent === currentWordData.definition) el.classList.add('correct');
                    });
                }
            }

            if(newWordBtn) newWordBtn.addEventListener('click', setupNewHangmanWord);
            if(tierFilter) tierFilter.addEventListener('change', setupNewHangmanWord);
            setupNewHangmanWord();
        })();

    </script>
</body>
</html>
