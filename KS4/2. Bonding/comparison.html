<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GCSE Chemistry: Bonding & Structure Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 0; }
        
        /* Custom Range Slider Styling */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%;
            background: #f59e0b; cursor: pointer; margin-top: -8px; box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #4b5563; border-radius: 2px;
        }

        /* Toggle Switch */
        .toggle-checkbox:checked { right: 0; border-color: #22c55e; }
        .toggle-checkbox:checked + .toggle-label { background-color: #22c55e; }
        
        .glass-panel {
            background: rgba(30, 41, 59, 0.90);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Transition classes for UI toggling */
        .ui-visible { opacity: 1; pointer-events: auto; }
        .ui-hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body class="text-white">

    <div id="canvas-container"></div>

    <!-- Toggle UI Button (Always Visible) -->
    <button id="btn-toggle-ui" class="absolute top-4 right-4 pointer-events-auto glass-panel p-2 rounded-lg text-gray-300 hover:text-white hover:bg-gray-700 transition-all z-50" title="Hide/Show Controls">
        <!-- Eye Open Icon -->
        <svg id="icon-eye" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
            <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
            <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
        </svg>
        <!-- Eye Closed Icon (Hidden initially) -->
        <svg id="icon-eye-off" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
            <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
            <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
            <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
        </svg>
    </button>

    <!-- UI Overlay Container -->
    <div id="ui-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none flex flex-col md:flex-row p-4 gap-4 transition-opacity duration-300 ui-visible">
        
        <!-- Controls Panel -->
        <div class="glass-panel pointer-events-auto p-6 rounded-xl w-full md:w-96 shadow-2xl flex flex-col gap-5 overflow-y-auto max-h-full">
            
            <!-- Compound Selector -->
            <div class="border-b border-gray-600 pb-4">
                <label class="block text-sm font-semibold mb-2 text-gray-300">Select Structure</label>
                <div class="flex rounded-md shadow-sm" role="group">
                    <button id="btn-nacl" class="flex-1 px-2 py-2 text-[10px] sm:text-xs font-bold bg-amber-600 text-white border border-amber-600 rounded-l-lg hover:bg-amber-700 active transition-colors">
                        Ionic (NaCl)
                    </button>
                    <button id="btn-water" class="flex-1 px-2 py-2 text-[10px] sm:text-xs font-bold bg-gray-700 text-gray-300 border border-gray-600 hover:bg-gray-600 transition-colors">
                        Simple (H₂O)
                    </button>
                    <button id="btn-sio2" class="flex-1 px-2 py-2 text-[10px] sm:text-xs font-bold bg-gray-700 text-gray-300 border border-gray-600 hover:bg-gray-600 transition-colors">
                        Giant (SiO₂)
                    </button>
                    <button id="btn-metal" class="flex-1 px-2 py-2 text-[10px] sm:text-xs font-bold bg-gray-700 text-gray-300 border border-gray-600 rounded-r-lg hover:bg-gray-600 transition-colors">
                        Metal (Mg)
                    </button>
                </div>
            </div>

            <!-- Context Info -->
            <div>
                <h1 id="compound-title" class="text-xl font-bold text-amber-400">Sodium Chloride</h1>
                <p id="compound-desc" class="text-xs text-gray-300 mt-1">Giant Ionic Lattice</p>
            </div>

            <!-- NaCl Environment Toggle (Hidden for Water/SiO2/Metal) -->
            <div id="env-controls">
                <label class="block text-sm font-semibold mb-2 text-blue-300">Environment</label>
                <div class="flex rounded-md shadow-sm" role="group">
                    <button id="btn-pure" class="flex-1 px-2 py-2 text-xs font-medium bg-blue-600 text-white border border-blue-600 rounded-l-lg hover:bg-blue-700 active">
                        Solid/Molten
                    </button>
                    <button id="btn-solution" class="flex-1 px-2 py-2 text-xs font-medium bg-gray-700 text-gray-300 border border-gray-600 rounded-r-lg hover:bg-gray-600">
                        Solution (Water)
                    </button>
                </div>
            </div>

            <!-- Temperature Control -->
            <div id="temp-control-group" class="transition-opacity duration-300">
                <div class="flex justify-between items-end mb-1">
                    <label class="block text-sm font-semibold text-red-300">Temperature</label>
                    <span id="temp-display" class="text-xl font-mono font-bold">20°C</span>
                </div>
                <input type="range" id="temp-slider" min="20" max="1000" value="20" step="1">
                <div id="temp-labels" class="flex justify-between text-xs text-gray-400 mt-1">
                    <!-- Populated by JS -->
                </div>
                <p id="state-text" class="text-sm mt-2 font-semibold text-center py-1 bg-gray-800 rounded border border-gray-600">State: <span class="text-green-400">Solid Lattice</span></p>
            </div>

            <!-- Power Supply Toggle -->
            <div>
                <label class="block text-sm font-semibold mb-2 text-yellow-300">Power Supply (DC)</label>
                <div class="flex items-center justify-between bg-gray-800 p-2 rounded-lg border border-gray-600">
                    <span class="text-sm font-medium">Circuit Switch</span>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="toggle" id="power-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer border-gray-300"/>
                        <label for="power-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
            </div>

            <!-- View Options -->
            <div id="view-options">
                <label class="block text-sm font-semibold mb-2 text-purple-300">Representation</label>
                <div class="flex flex-col gap-2">
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="radio" name="viewMode" value="ballstick" checked class="form-radio text-blue-600">
                        <span class="text-sm">Ball and Stick</span>
                    </label>
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="radio" name="viewMode" value="spacefill" class="form-radio text-blue-600">
                        <span class="text-sm">Space Filling</span>
                    </label>
                </div>
            </div>

            <!-- Conductivity Indicator -->
            <div class="bg-gray-800 p-4 rounded-lg border border-gray-600">
                <div class="flex items-center gap-3">
                    <div id="bulb-icon" class="w-8 h-8 rounded-full bg-gray-700 border-2 border-gray-500 shadow-inner transition-all duration-500"></div>
                    <div>
                        <h3 class="text-sm font-bold">Conductivity</h3>
                        <p id="conductivity-status" class="text-xs text-gray-400">Circuit Off</p>
                    </div>
                </div>
                <p id="conductivity-reason" class="text-xs text-gray-400 mt-2 italic border-t border-gray-700 pt-2">
                    Switch on the power to test conductivity.
                </p>
            </div>

            <!-- Legend -->
            <div id="legend-container" class="flex flex-wrap justify-around items-center pt-2 border-t border-gray-600 gap-2">
                <!-- Populated by JS -->
            </div>
        </div>

        <!-- Navigation Controls (Bottom Right) -->
        <div class="pointer-events-auto absolute bottom-4 right-4 flex flex-col gap-3 items-end">
            
            <!-- Mouse Interaction Mode -->
            <div class="glass-panel p-2 rounded-lg flex gap-2">
                <button id="btn-mode-rotate" class="w-10 h-10 bg-blue-600 rounded text-white flex items-center justify-center transition-colors" title="Rotate (Orbit) Mode">
                    <!-- Rotate Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                        <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                    </svg>
                </button>
                <button id="btn-mode-pan" class="w-10 h-10 bg-gray-700 hover:bg-gray-600 rounded text-white flex items-center justify-center transition-colors" title="Pan (Move) Mode">
                    <!-- Hand/Move Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"/>
                        <path d="M8 2a.5.5 0 0 1 .5.5v2h2a.5.5 0 0 1 0 1h-2v2h2a.5.5 0 0 1 0 1h-2v2a.5.5 0 0 1-1 0v-2h-2a.5.5 0 0 1 0-1h2v-2h-2a.5.5 0 0 1 0-1h2v-2A.5.5 0 0 1 8 2z" opacity="0.5"/> <!-- Hint at movement -->
                        <path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z" transform="rotate(45 8 8) scale(0.6)" style="display:none"/> <!-- Alternate arrow approach, using hand below -->
                        <path d="M7.75 1a.75.75 0 0 1 .75.75V7h.25a.25.25 0 0 0 .25-.25v-2a.75.75 0 0 1 1.5 0v2.5a.25.25 0 0 0 .25.25h.25a.25.25 0 0 0 .25-.25v-2.5a.75.75 0 0 1 1.5 0v2.5a.25.25 0 0 0 .25.25h.25a.25.25 0 0 0 .25-.25v-2.5a.75.75 0 0 1 1.5 0v5.5a4.75 4.75 0 0 1-9.5 0v-5.5a.75.75 0 0 1 1.5 0v2a.25.25 0 0 0 .25.25h.25a.25.25 0 0 0 .25-.25V1.75A.75.75 0 0 1 7.75 1z" />
                    </svg>
                </button>
            </div>

            <!-- Zoom -->
            <div class="glass-panel p-2 rounded-lg flex flex-col gap-2 items-center w-12">
                <button id="btn-zoom-in" class="w-8 h-8 bg-gray-700 hover:bg-gray-600 rounded text-white font-bold flex items-center justify-center transition-colors" title="Zoom In">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>
                </button>
                <button id="btn-zoom-out" class="w-8 h-8 bg-gray-700 hover:bg-gray-600 rounded text-white font-bold flex items-center justify-center transition-colors" title="Zoom Out">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/></svg>
                </button>
            </div>
            
            <!-- Rotate -->
            <div class="glass-panel p-2 rounded-lg grid grid-cols-3 gap-1">
                <div class="col-start-2">
                    <button id="btn-rot-up" class="w-10 h-10 bg-gray-700 hover:bg-gray-600 rounded text-white flex items-center justify-center transition-colors" title="Rotate Up">↑</button>
                </div>
                <div class="col-start-1 row-start-2">
                    <button id="btn-rot-left" class="w-10 h-10 bg-gray-700 hover:bg-gray-600 rounded text-white flex items-center justify-center transition-colors" title="Rotate Left">←</button>
                </div>
                <div class="col-start-2 row-start-2">
                    <button id="btn-rot-down" class="w-10 h-10 bg-gray-700 hover:bg-gray-600 rounded text-white flex items-center justify-center transition-colors" title="Rotate Down">↓</button>
                </div>
                <div class="col-start-3 row-start-2">
                    <button id="btn-rot-right" class="w-10 h-10 bg-gray-700 hover:bg-gray-600 rounded text-white flex items-center justify-center transition-colors" title="Rotate Right">→</button>
                </div>
            </div>
            
            <!-- Reset -->
            <button id="btn-reset-cam" class="glass-panel px-4 py-2 rounded-lg font-semibold hover:bg-gray-700 text-sm transition-colors text-gray-200">
                Reset View
            </button>
        </div>
    </div>

    <!-- Simulation Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        // Common
        const state = {
            compound: 'nacl', // 'nacl', 'water', 'sio2', 'metal'
            temp: 20,
            time: 0,
            isPowerOn: false,
            isUIVisible: true,
            
            // NaCl Specific
            nacl: {
                isMolten: false,
                inSolution: false,
                viewMode: 'ballstick',
                meltingPoint: 801
            },

            // Water Specific
            water: {
                phase: 'liquid',
                meltingPoint: 0,
                boilingPoint: 100
            },

            // SiO2 Specific
            sio2: {
                isMolten: false,
                meltingPoint: 1710,
                viewMode: 'ballstick'
            },

            // Metal Specific
            metal: {
                isMolten: false,
                meltingPoint: 650, // Magnesium approx
                viewMode: 'ballstick' // Doesn't really apply but kept for consistency in code structure
            }
        };

        // Colors
        const COLORS = {
            na: 0xcccccc, cl: 0x22c55e, bond: 0x666666,
            o: 0xff3333, h: 0xffffff,
            si: 0xe6c9a8, // Tan/Beige for visibility on dark background
            sio2_bond: 0x999999,
            interForce: 0x88ccff,
            metalIon: 0xe5e7eb, // Bright Silver for Magnesium
            electron: 0xfacc15 // Yellow
        };

        // DOM Elements
        const els = {
            btnNacl: document.getElementById('btn-nacl'),
            btnWater: document.getElementById('btn-water'),
            btnSio2: document.getElementById('btn-sio2'),
            btnMetal: document.getElementById('btn-metal'),
            title: document.getElementById('compound-title'),
            desc: document.getElementById('compound-desc'),
            envControls: document.getElementById('env-controls'),
            viewOptions: document.getElementById('view-options'),
            tempSlider: document.getElementById('temp-slider'),
            tempDisplay: document.getElementById('temp-display'),
            tempLabels: document.getElementById('temp-labels'),
            stateText: document.getElementById('state-text'),
            btnPure: document.getElementById('btn-pure'),
            btnSolution: document.getElementById('btn-solution'),
            bulb: document.getElementById('bulb-icon'),
            condStatus: document.getElementById('conductivity-status'),
            condReason: document.getElementById('conductivity-reason'),
            powerToggle: document.getElementById('power-toggle'),
            legend: document.getElementById('legend-container'),
            // Nav Controls
            btnZoomIn: document.getElementById('btn-zoom-in'),
            btnZoomOut: document.getElementById('btn-zoom-out'),
            btnRotUp: document.getElementById('btn-rot-up'),
            btnRotDown: document.getElementById('btn-rot-down'),
            btnRotLeft: document.getElementById('btn-rot-left'),
            btnRotRight: document.getElementById('btn-rot-right'),
            btnResetCam: document.getElementById('btn-reset-cam'),
            // Mode Controls
            btnModeRotate: document.getElementById('btn-mode-rotate'),
            btnModePan: document.getElementById('btn-mode-pan'),
            // UI Toggle
            btnToggleUI: document.getElementById('btn-toggle-ui'),
            uiLayer: document.getElementById('ui-layer'),
            iconEye: document.getElementById('icon-eye'),
            iconEyeOff: document.getElementById('icon-eye-off')
        };

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 20, 60);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Navigation Logic
        function zoomCamera(direction) {
            // Direction: 1 for in, -1 for out
            const dist = camera.position.distanceTo(controls.target);
            const newDist = THREE.MathUtils.clamp(dist - (direction * 5), 5, 100);
            
            const vec = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).add(vec.multiplyScalar(newDist));
        }

        function rotateCamera(x, y) {
            // Orbit around the target
            const offset = new THREE.Vector3().subVectors(camera.position, controls.target);
            const spherical = new THREE.Spherical().setFromVector3(offset);
            
            spherical.theta -= x * 0.2; // Left/Right
            spherical.phi -= y * 0.2;   // Up/Down
            
            // Clamp phi to avoid locking at poles
            spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

            offset.setFromSpherical(spherical);
            camera.position.copy(controls.target).add(offset);
            camera.lookAt(controls.target);
        }

        function resetCamera() {
            camera.position.set(15, 15, 15);
            controls.target.set(0, 0, 0);
            camera.lookAt(0,0,0);
        }

        function setInteractionMode(mode) {
            // Default OrbitControls: LEFT = ROTATE, MIDDLE = DOLLY, RIGHT = PAN
            if (mode === 'rotate') {
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.ROTATE,
                    MIDDLE: THREE.MOUSE.DOLLY,
                    RIGHT: THREE.MOUSE.PAN
                };
                // UI
                els.btnModeRotate.classList.add('bg-blue-600');
                els.btnModeRotate.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                els.btnModePan.classList.remove('bg-blue-600');
                els.btnModePan.classList.add('bg-gray-700', 'hover:bg-gray-600');
            } else if (mode === 'pan') {
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.PAN,
                    MIDDLE: THREE.MOUSE.DOLLY,
                    RIGHT: THREE.MOUSE.ROTATE
                };
                // UI
                els.btnModePan.classList.add('bg-blue-600');
                els.btnModePan.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                els.btnModeRotate.classList.remove('bg-blue-600');
                els.btnModeRotate.classList.add('bg-gray-700', 'hover:bg-gray-600');
            }
        }

        // Nav Event Listeners
        els.btnZoomIn.addEventListener('click', () => zoomCamera(1));
        els.btnZoomOut.addEventListener('click', () => zoomCamera(-1));
        
        els.btnRotLeft.addEventListener('click', () => rotateCamera(1, 0));
        els.btnRotRight.addEventListener('click', () => rotateCamera(-1, 0));
        els.btnRotUp.addEventListener('click', () => rotateCamera(0, 1));
        els.btnRotDown.addEventListener('click', () => rotateCamera(0, -1));
        
        els.btnResetCam.addEventListener('click', resetCamera);

        els.btnModeRotate.addEventListener('click', () => setInteractionMode('rotate'));
        els.btnModePan.addEventListener('click', () => setInteractionMode('pan'));

        // UI Toggle
        els.btnToggleUI.addEventListener('click', () => {
            state.isUIVisible = !state.isUIVisible;
            
            if (state.isUIVisible) {
                els.uiLayer.classList.remove('ui-hidden');
                els.uiLayer.classList.add('ui-visible');
                els.iconEye.classList.remove('hidden');
                els.iconEyeOff.classList.add('hidden');
            } else {
                els.uiLayer.classList.remove('ui-visible');
                els.uiLayer.classList.add('ui-hidden');
                els.iconEye.classList.add('hidden');
                els.iconEyeOff.classList.remove('hidden');
            }
        });


        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- Groups ---
        const naclGroup = new THREE.Group();
        const waterGroup = new THREE.Group();
        const sio2Group = new THREE.Group();
        const metalGroup = new THREE.Group();
        const electrodeGroup = new THREE.Group();
        scene.add(naclGroup);
        scene.add(waterGroup);
        scene.add(sio2Group);
        scene.add(metalGroup);
        scene.add(electrodeGroup);

        // Physics Arrays
        let ions = [];
        let bonds = [];
        let molecules = [];
        let intermolecularLines = [];
        let sio2Atoms = [];
        let sio2Bonds = [];
        let metalIons = [];
        let electrons = [];

        // --- Shared Geometry ---
        const sphereGeo = new THREE.SphereGeometry(1, 16, 16); // Reduced detail for perf
        const bondGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
        const electronGeo = new THREE.SphereGeometry(0.15, 8, 8);
        
        // Materials
        const matNa = new THREE.MeshStandardMaterial({ color: COLORS.na, roughness: 0.3, metalness: 0.1 });
        const matCl = new THREE.MeshStandardMaterial({ color: COLORS.cl, roughness: 0.2, transparent: true, opacity: 0.9 });
        const matO = new THREE.MeshStandardMaterial({ color: COLORS.o, roughness: 0.2 });
        const matH = new THREE.MeshStandardMaterial({ color: COLORS.h, roughness: 0.2 });
        const matSi = new THREE.MeshStandardMaterial({ color: COLORS.si, roughness: 0.3, metalness: 0.2 });
        const matBond = new THREE.MeshStandardMaterial({ color: COLORS.bond });
        const matSiBond = new THREE.MeshStandardMaterial({ color: COLORS.sio2_bond });
        const matInter = new THREE.LineDashedMaterial({ color: COLORS.interForce, dashSize: 0.2, gapSize: 0.1, opacity: 0.5, transparent: true });
        const matMetalIon = new THREE.MeshStandardMaterial({ color: COLORS.metalIon, roughness: 0.2, metalness: 0.8 });
        const matElectron = new THREE.MeshBasicMaterial({ color: COLORS.electron });

        // --- Electrodes Setup ---
        const boxSize = 12;
        const anodeGeo = new THREE.BoxGeometry(0.5, boxSize, boxSize);
        const cathodeGeo = new THREE.BoxGeometry(0.5, boxSize, boxSize);
        const anode = new THREE.Mesh(anodeGeo, new THREE.MeshStandardMaterial({ color: 0xff3333, transparent: true, opacity: 0.4 }));
        const cathode = new THREE.Mesh(cathodeGeo, new THREE.MeshStandardMaterial({ color: 0x3333ff, transparent: true, opacity: 0.4 }));
        anode.position.set(-8, 0, 0);
        cathode.position.set(8, 0, 0);
        
        function createTextSprite(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, 128, 70);
            const map = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: map }));
            sprite.scale.set(6, 3, 1);
            return sprite;
        }
        const anodeLabel = createTextSprite("Anode (+)", "#ffcccc");
        const cathodeLabel = createTextSprite("Cathode (-)", "#ccccff");
        anodeLabel.position.set(0, 7, 0);
        cathodeLabel.position.set(0, 7, 0);
        anode.add(anodeLabel);
        cathode.add(cathodeLabel);
        electrodeGroup.add(anode);
        electrodeGroup.add(cathode);
        electrodeGroup.visible = false;


        // --- NaCl Logic ---
        function initNaCl() {
            ions.forEach(i => { if(i.mesh.geometry) i.mesh.geometry.dispose(); naclGroup.remove(i.mesh); });
            bonds.forEach(b => naclGroup.remove(b.mesh));
            ions = []; bonds = [];
            
            const GRID = 4; const SPACING = 2.5; const offset = (GRID - 1) * SPACING / 2;
            for (let x = 0; x < GRID; x++) {
                for (let y = 0; y < GRID; y++) {
                    for (let z = 0; z < GRID; z++) {
                        const isNa = (x + y + z) % 2 === 0;
                        const mesh = new THREE.Mesh(sphereGeo, isNa ? matNa : matCl);
                        const basePos = new THREE.Vector3(x*SPACING - offset, y*SPACING - offset, z*SPACING - offset);
                        mesh.position.copy(basePos);
                        ions.push({ mesh: mesh, basePos: basePos, liquidPos: basePos.clone(), type: isNa ? 'Na' : 'Cl', velocity: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(0.05) });
                        naclGroup.add(mesh);
                        if (x < GRID - 1) createNaClBond(basePos, new THREE.Vector3(basePos.x + SPACING, basePos.y, basePos.z), 'x');
                        if (y < GRID - 1) createNaClBond(basePos, new THREE.Vector3(basePos.x, basePos.y + SPACING, basePos.z), 'y');
                        if (z < GRID - 1) createNaClBond(basePos, new THREE.Vector3(basePos.x, basePos.y, basePos.z + SPACING), 'z');
                    }
                }
            }
        }
        function createNaClBond(v1, v2, axis) {
            const bond = new THREE.Mesh(bondGeo, matBond);
            const mid = v1.clone().add(v2).multiplyScalar(0.5);
            bond.position.copy(mid);
            if (axis === 'x') bond.rotation.z = Math.PI / 2;
            if (axis === 'z') bond.rotation.x = Math.PI / 2;
            bond.scale.y = 2.5;
            naclGroup.add(bond);
            bonds.push({ mesh: bond, axis: axis });
        }

        // --- Water Logic ---
        function initWater() {
            molecules.forEach(m => waterGroup.remove(m.group));
            intermolecularLines.forEach(l => waterGroup.remove(l.line));
            molecules = []; intermolecularLines = [];
            const rows = 3; const cols = 3; const layers = 3; const SPACING_X = 3.5; const SPACING_Z = 3.5; const SPACING_Y = 3.0;
            for(let y=0; y<layers; y++) {
                for(let z=0; z<cols; z++) {
                    for(let x=0; x<rows; x++) {
                        const offsetX = (z % 2 === 0) ? 0 : SPACING_X / 2;
                        const px = (x * SPACING_X) + offsetX - 5; const py = (y * SPACING_Y) - 4; const pz = (z * SPACING_Z) - 5;
                        createWaterMolecule(new THREE.Vector3(px, py, pz));
                    }
                }
            }
            molecules.forEach((m1, i) => {
                molecules.forEach((m2, j) => {
                    if (i < j) {
                        const geometry = new THREE.BufferGeometry().setFromPoints([m1.basePos, m2.basePos]);
                        const line = new THREE.Line(geometry, matInter);
                        line.visible = false; waterGroup.add(line);
                        intermolecularLines.push({ line: line, m1: m1, m2: m2 });
                    }
                });
            });
        }
        function createWaterMolecule(pos) {
            const group = new THREE.Group();
            const oMesh = new THREE.Mesh(sphereGeo, matO); oMesh.scale.set(0.8, 0.8, 0.8); group.add(oMesh);
            const h1 = new THREE.Mesh(sphereGeo, matH); h1.scale.set(0.4, 0.4, 0.4); h1.position.set(0.7, -0.4, 0); group.add(h1);
            const h2 = new THREE.Mesh(sphereGeo, matH); h2.scale.set(0.4, 0.4, 0.4); h2.position.set(-0.7, -0.4, 0); group.add(h2);
            const bond1 = new THREE.Mesh(bondGeo, matBond); bond1.scale.set(0.5, 0.8, 0.5); bond1.position.set(0.35, -0.2, 0); bond1.rotation.z = -0.5; group.add(bond1);
            const bond2 = new THREE.Mesh(bondGeo, matBond); bond2.scale.set(0.5, 0.8, 0.5); bond2.position.set(-0.35, -0.2, 0); bond2.rotation.z = 0.5; group.add(bond2);
            group.position.copy(pos); waterGroup.add(group);
            molecules.push({ group: group, basePos: pos.clone(), liquidPos: pos.clone(), velocity: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(0.08) });
        }

        // --- SiO2 Logic ---
        function initSiO2() {
            sio2Atoms.forEach(a => { if(a.mesh.geometry) a.mesh.geometry.dispose(); sio2Group.remove(a.mesh); });
            sio2Bonds.forEach(b => sio2Group.remove(b.mesh));
            sio2Atoms = []; sio2Bonds = [];
            const scale = 3.5;
            const basis = [[0,0,0], [0.25, 0.25, 0.25]];
            const points = [];
            const gridSize = 2; 

            for(let x=0; x<gridSize; x++) {
                for(let y=0; y<gridSize; y++) {
                    for(let z=0; z<gridSize; z++) {
                        const fcc = [[0,0,0], [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5]];
                        fcc.forEach(offset => {
                            basis.forEach(b => {
                                const px = (x + offset[0] + b[0]) * scale;
                                const py = (y + offset[1] + b[1]) * scale;
                                const pz = (z + offset[2] + b[2]) * scale;
                                points.push(new THREE.Vector3(px - (gridSize*scale)/2, py - (gridSize*scale)/2, pz - (gridSize*scale)/2));
                            });
                        });
                    }
                }
            }

            const siliconAtoms = [];
            points.forEach(p => {
                const mesh = new THREE.Mesh(sphereGeo, matSi);
                mesh.position.copy(p);
                const atom = { mesh: mesh, basePos: p.clone(), liquidPos: p.clone(), type: 'Si', velocity: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(0.03) };
                sio2Atoms.push(atom);
                siliconAtoms.push(atom);
                sio2Group.add(mesh);
            });

            const bondDistSq = (0.44 * scale) ** 2; 
            for(let i=0; i<siliconAtoms.length; i++) {
                for(let j=i+1; j<siliconAtoms.length; j++) {
                    const p1 = siliconAtoms[i].basePos;
                    const p2 = siliconAtoms[j].basePos;
                    if (p1.distanceToSquared(p2) < bondDistSq) {
                        const mid = p1.clone().add(p2).multiplyScalar(0.5);
                        const oMesh = new THREE.Mesh(sphereGeo, matO);
                        oMesh.position.copy(mid);
                        const oAtom = { mesh: oMesh, basePos: mid.clone(), liquidPos: mid.clone(), type: 'O', velocity: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(0.03) };
                        sio2Atoms.push(oAtom);
                        sio2Group.add(oMesh);
                        createSiO2Bond(p1, mid);
                        createSiO2Bond(mid, p2);
                    }
                }
            }
        }

        function createSiO2Bond(v1, v2) {
            const bond = new THREE.Mesh(bondGeo, matSiBond);
            const mid = v1.clone().add(v2).multiplyScalar(0.5);
            const dist = v1.distanceTo(v2);
            bond.position.copy(mid);
            bond.lookAt(v2);
            bond.rotateX(Math.PI / 2);
            bond.scale.set(0.6, dist, 0.6);
            sio2Group.add(bond);
            sio2Bonds.push({ mesh: bond, v1: v1, v2: v2 });
        }

        // --- Giant Metallic Lattice Logic ---
        function initMetal() {
            metalIons.forEach(i => metalGroup.remove(i.mesh));
            electrons.forEach(e => metalGroup.remove(e.mesh));
            metalIons = []; electrons = [];

            // Create Layers of Positive Ions
            const GRID = 4;
            const SPACING = 2.8;
            const offset = (GRID - 1) * SPACING / 2;

            for (let x = 0; x < GRID; x++) {
                for (let y = 0; y < GRID; y++) {
                    for (let z = 0; z < GRID; z++) {
                        const mesh = new THREE.Mesh(sphereGeo, matMetalIon);
                        const basePos = new THREE.Vector3(x*SPACING - offset, y*SPACING - offset, z*SPACING - offset);
                        mesh.position.copy(basePos);
                        
                        metalIons.push({
                            mesh: mesh,
                            basePos: basePos,
                            liquidPos: basePos.clone(),
                            velocity: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(0.04)
                        });
                        metalGroup.add(mesh);
                    }
                }
            }

            // Create Sea of Delocalised Electrons
            // More electrons than ions to visualize the "sea"
            const electronCount = metalIons.length * 3;
            for(let i=0; i<electronCount; i++) {
                const mesh = new THREE.Mesh(electronGeo, matElectron);
                // Scatter randomly within the box
                const px = (Math.random() - 0.5) * GRID * SPACING;
                const py = (Math.random() - 0.5) * GRID * SPACING;
                const pz = (Math.random() - 0.5) * GRID * SPACING;
                mesh.position.set(px, py, pz);
                
                electrons.push({
                    mesh: mesh,
                    velocity: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(0.2) 
                });
                metalGroup.add(mesh);
            }
        }

        // --- Physics Loop ---
        function updatePhysics() {
            state.time += 0.05;
            const boundary = 7;
            if (state.compound === 'nacl') updateNaClPhysics(boundary);
            else if (state.compound === 'water') updateWaterPhysics(boundary);
            else if (state.compound === 'sio2') updateSiO2Physics(boundary);
            else if (state.compound === 'metal') updateMetalPhysics(boundary);
        }

        function updateNaClPhysics(boundary) {
            const vib = (state.temp / 1500) * 0.3;
            const electricField = 0.08;
            ions.forEach(ion => {
                if (state.nacl.inSolution) {
                    let move = ion.velocity.clone().multiplyScalar(2);
                    if (state.isPowerOn) move.x += (ion.type === 'Na' ? electricField : -electricField);
                    ion.liquidPos.add(move);
                    ['x', 'y', 'z'].forEach(ax => { if (Math.abs(ion.liquidPos[ax]) > boundary) { ion.velocity[ax] *= -1; ion.liquidPos[ax] = Math.sign(ion.liquidPos[ax]) * boundary * 0.99; } });
                    ion.mesh.position.lerp(ion.liquidPos, 0.2);
                } else if (state.nacl.isMolten) {
                    let move = ion.velocity.clone();
                    if (state.isPowerOn) move.x += (ion.type === 'Na' ? electricField : -electricField);
                    ion.liquidPos.add(move);
                    ['x', 'y', 'z'].forEach(ax => { if (Math.abs(ion.liquidPos[ax]) > boundary) { ion.velocity[ax] *= -1; ion.liquidPos[ax] = Math.sign(ion.liquidPos[ax]) * boundary * 0.99; } });
                    ion.mesh.position.x = ion.liquidPos.x + Math.sin(state.time * 5 + ion.basePos.y) * 0.05;
                    ion.mesh.position.y = ion.liquidPos.y + Math.cos(state.time * 4 + ion.basePos.z) * 0.05;
                    ion.mesh.position.z = ion.liquidPos.z + Math.sin(state.time * 6 + ion.basePos.x) * 0.05;
                } else {
                    ion.liquidPos.lerp(ion.basePos, 0.1);
                    ion.mesh.position.x = ion.liquidPos.x + Math.sin(state.time*10 + ion.basePos.y) * vib;
                    ion.mesh.position.y = ion.liquidPos.y + Math.cos(state.time*12 + ion.basePos.z) * vib;
                    ion.mesh.position.z = ion.liquidPos.z + Math.sin(state.time*11 + ion.basePos.x) * vib;
                }
            });
            if (state.nacl.isMolten || state.nacl.inSolution) {
                for(let i=0; i<ions.length; i++) {
                    for(let j=i+1; j<ions.length; j++) {
                        if(ions[i].liquidPos.distanceToSquared(ions[j].liquidPos) < 4) {
                            const dir = ions[i].liquidPos.clone().sub(ions[j].liquidPos).normalize().multiplyScalar(0.05);
                            ions[i].liquidPos.add(dir); ions[j].liquidPos.sub(dir);
                        }
                    }
                }
            }
            const isBallStick = state.nacl.viewMode === 'ballstick';
            ions.forEach(ion => { let s = isBallStick ? (ion.type === 'Na' ? 0.6 : 0.9) : (ion.type === 'Na' ? 1.4 : 2.2); ion.mesh.scale.setScalar(s); });
            bonds.forEach(b => b.mesh.visible = (!state.nacl.isMolten && !state.nacl.inSolution && isBallStick));
        }

        function updateWaterPhysics(boundary) {
            const phase = state.water.phase;
            intermolecularLines.forEach(item => {
                const p1 = item.m1.group.position; const p2 = item.m2.group.position; const dist = p1.distanceTo(p2);
                const positions = item.line.geometry.attributes.position.array;
                positions[0] = p1.x; positions[1] = p1.y; positions[2] = p1.z; positions[3] = p2.x; positions[4] = p2.y; positions[5] = p2.z;
                item.line.geometry.attributes.position.needsUpdate = true;
                if (phase === 'gas') item.line.visible = false;
                else if (phase === 'solid') item.line.visible = dist < 4.5;
                else item.line.visible = dist < 5.0;
                if (item.line.visible) item.line.computeLineDistances();
            });
            molecules.forEach(mol => {
                if (phase === 'solid') {
                    mol.liquidPos.lerp(mol.basePos, 0.1);
                    mol.group.position.x = mol.liquidPos.x + Math.sin(state.time * 5 + mol.basePos.y) * 0.05;
                    mol.group.position.y = mol.liquidPos.y + Math.cos(state.time * 7 + mol.basePos.z) * 0.05;
                    mol.group.position.z = mol.liquidPos.z + Math.sin(state.time * 3 + mol.basePos.x) * 0.05;
                    mol.group.rotation.z = Math.sin(state.time * 2) * 0.1;
                } else if (phase === 'liquid') {
                    const move = mol.velocity.clone().multiplyScalar(0.8); mol.liquidPos.add(move);
                    const limitY = 2; ['x', 'y', 'z'].forEach(ax => { const lim = (ax === 'y' && mol.liquidPos[ax] > limitY) ? limitY : boundary; if (Math.abs(mol.liquidPos[ax]) > lim) { mol.velocity[ax] *= -1; mol.liquidPos[ax] = Math.sign(mol.liquidPos[ax]) * lim * 0.95; } });
                    mol.group.position.lerp(mol.liquidPos, 0.2); mol.group.rotation.z += 0.02; mol.group.rotation.x += 0.01;
                } else {
                    const move = mol.velocity.clone().multiplyScalar(3.0); mol.liquidPos.add(move);
                    ['x', 'y', 'z'].forEach(ax => { if (Math.abs(mol.liquidPos[ax]) > boundary * 1.5) { mol.velocity[ax] *= -1; } });
                    mol.group.position.lerp(mol.liquidPos, 0.2); mol.group.rotation.z += 0.1; mol.group.rotation.x += 0.1;
                }
            });
            if (phase !== 'solid') {
                for(let i=0; i<molecules.length; i++) {
                    for(let j=i+1; j<molecules.length; j++) {
                        if(molecules[i].liquidPos.distanceToSquared(molecules[j].liquidPos) < (phase === 'liquid' ? 6.25 : 16)) {
                            const dir = molecules[i].liquidPos.clone().sub(molecules[j].liquidPos).normalize().multiplyScalar(0.05);
                            molecules[i].liquidPos.add(dir); molecules[j].liquidPos.sub(dir);
                        }
                    }
                }
            }
        }

        function updateSiO2Physics(boundary) {
            const vib = (state.temp / 2500) * 0.2; 
            const isBallStick = state.sio2.viewMode === 'ballstick';
            
            sio2Atoms.forEach(atom => {
                if (state.sio2.isMolten) {
                    let move = atom.velocity.clone().multiplyScalar(0.5); 
                    atom.liquidPos.add(move);
                    ['x', 'y', 'z'].forEach(ax => { if (Math.abs(atom.liquidPos[ax]) > boundary) { atom.velocity[ax] *= -1; atom.liquidPos[ax] = Math.sign(atom.liquidPos[ax]) * boundary * 0.99; } });
                    atom.mesh.position.lerp(atom.liquidPos, 0.1);
                } else {
                    atom.liquidPos.lerp(atom.basePos, 0.1);
                    atom.mesh.position.x = atom.liquidPos.x + Math.sin(state.time * 15 + atom.basePos.y) * vib;
                    atom.mesh.position.y = atom.liquidPos.y + Math.cos(state.time * 13 + atom.basePos.z) * vib;
                    atom.mesh.position.z = atom.liquidPos.z + Math.sin(state.time * 14 + atom.basePos.x) * vib;
                }
                let s = 1.0;
                if (isBallStick) s = atom.type === 'Si' ? 0.35 : 0.25; 
                else s = atom.type === 'Si' ? 0.9 : 0.65; 
                atom.mesh.scale.setScalar(s);
            });
            const showBonds = !state.sio2.isMolten && isBallStick;
            sio2Bonds.forEach(b => { b.mesh.visible = showBonds; });
        }

        function updateMetalPhysics(boundary) {
            const vib = (state.temp / 1000) * 0.3;
            
            // Ions Logic
            metalIons.forEach(ion => {
                if (state.metal.isMolten) {
                    // Molten: Ions flow
                    let move = ion.velocity.clone();
                    ion.liquidPos.add(move);
                    ['x', 'y', 'z'].forEach(ax => { 
                        if (Math.abs(ion.liquidPos[ax]) > boundary) { 
                            ion.velocity[ax] *= -1; 
                            ion.liquidPos[ax] = Math.sign(ion.liquidPos[ax]) * boundary * 0.99; 
                        } 
                    });
                    
                    // Simple collision between ions in liquid
                    // (Simplified loop here or just basic avoidance handled by box logic + visuals)
                    
                    ion.mesh.position.lerp(ion.liquidPos, 0.2);
                } else {
                    // Solid: Vibrate in lattice
                    ion.liquidPos.lerp(ion.basePos, 0.1);
                    ion.mesh.position.x = ion.liquidPos.x + Math.sin(state.time * 10 + ion.basePos.y) * vib;
                    ion.mesh.position.y = ion.liquidPos.y + Math.cos(state.time * 12 + ion.basePos.z) * vib;
                    ion.mesh.position.z = ion.liquidPos.z + Math.sin(state.time * 11 + ion.basePos.x) * vib;
                }
            });
            
            if (state.metal.isMolten) {
                for(let i=0; i<metalIons.length; i++) {
                    for(let j=i+1; j<metalIons.length; j++) {
                        if(metalIons[i].liquidPos.distanceToSquared(metalIons[j].liquidPos) < 2.5) {
                            const dir = metalIons[i].liquidPos.clone().sub(metalIons[j].liquidPos).normalize().multiplyScalar(0.05);
                            metalIons[i].liquidPos.add(dir); metalIons[j].liquidPos.sub(dir);
                        }
                    }
                }
            }

            // Electron Logic (Always Moving)
            const electronSpeed = 0.2;
            const driftSpeed = 0.15;
            
            electrons.forEach(e => {
                let move = e.velocity.clone().multiplyScalar(electronSpeed);
                
                // Conduction: Electrons drift to Anode (+X)
                // Wait, Anode is Left (-X) in our setup (Red box at x=-8)
                // Cathode is Right (+X) (Blue box at x=8)
                // Electrons (Negative) are attracted to Anode (Positive/Left)
                if (state.isPowerOn) {
                    move.x -= driftSpeed; // Move Left
                }
                
                e.mesh.position.add(move);
                
                // Boundaries for electrons
                const eBound = boundary + 0.5;
                ['x', 'y', 'z'].forEach(ax => {
                    if (Math.abs(e.mesh.position[ax]) > eBound) {
                        // Warp around or bounce? Bounce is better for box containment
                        // If power is on, they might "cycle" (enter right, leave left)
                        if (state.isPowerOn && ax === 'x') {
                            if (e.mesh.position.x < -eBound) e.mesh.position.x = eBound; // Loop back to cathode
                            if (e.mesh.position.x > eBound) e.mesh.position.x = -eBound;
                        } else {
                             e.velocity[ax] *= -1;
                             e.mesh.position[ax] = Math.sign(e.mesh.position[ax]) * eBound * 0.99;
                        }
                    }
                });
                
                // Random pertubation
                e.velocity.x += (Math.random()-0.5)*0.1;
                e.velocity.y += (Math.random()-0.5)*0.1;
                e.velocity.z += (Math.random()-0.5)*0.1;
                e.velocity.normalize();
            });
        }


        // --- UI & State Management ---
        function updateUI() {
            // Defaults
            naclGroup.visible = false; waterGroup.visible = false; sio2Group.visible = false; metalGroup.visible = false;
            els.envControls.style.display = "none";
            els.viewOptions.style.display = "block";
            
            // Button Styles Reset
            [els.btnNacl, els.btnWater, els.btnSio2, els.btnMetal].forEach(b => {
                 b.className = b.className.replace('bg-amber-600', 'bg-gray-700').replace('border-amber-600', 'border-gray-600');
            });

            if (state.compound === 'nacl') {
                naclGroup.visible = true;
                els.envControls.style.display = "block";
                styleActiveBtn(els.btnNacl);
                els.title.innerText = "Sodium Chloride (NaCl)";
                els.desc.innerText = "Giant Ionic Lattice";
                els.tempSlider.min = 20; els.tempSlider.max = 1000;
                els.tempLabels.innerHTML = `<span>20°C</span><span class="text-red-500 font-bold">MP: 801°C</span><span>1000°C</span>`;
                els.legend.innerHTML = `
                    <div class="flex items-center gap-2"><div class="w-4 h-4 rounded-full bg-green-500"></div><span class="text-xs">Cl⁻</span></div>
                    <div class="flex items-center gap-2"><div class="w-4 h-4 rounded-full bg-gray-300"></div><span class="text-xs">Na⁺</span></div>
                `;
            } else if (state.compound === 'water') {
                waterGroup.visible = true;
                els.viewOptions.style.display = "none"; // Water has fixed view
                styleActiveBtn(els.btnWater);
                els.title.innerText = "Water (H₂O)";
                els.desc.innerText = "Simple Molecular Structure";
                els.tempSlider.min = -50; els.tempSlider.max = 150;
                els.tempLabels.innerHTML = `<span>-50°C</span><span class="text-blue-300 font-bold">MP: 0°C</span><span class="text-red-400 font-bold">BP: 100°C</span><span>150°C</span>`;
                els.legend.innerHTML = `
                    <div class="flex items-center gap-2"><div class="w-4 h-4 rounded-full bg-red-500"></div><span class="text-xs">Oxygen</span></div>
                    <div class="flex items-center gap-2"><div class="w-4 h-4 rounded-full bg-white border border-gray-500"></div><span class="text-xs">Hydrogen</span></div>
                    <div class="flex items-center gap-2"><div class="w-8 h-0 border-t-2 border-dashed border-blue-300"></div><span class="text-[10px]">Intermolecular Force</span></div>
                `;
            } else if (state.compound === 'sio2') {
                sio2Group.visible = true;
                styleActiveBtn(els.btnSio2);
                els.title.innerText = "Silicon Dioxide (SiO₂)";
                els.desc.innerText = "Giant Covalent Lattice";
                els.tempSlider.min = 20; els.tempSlider.max = 2500;
                els.tempLabels.innerHTML = `<span>20°C</span><span class="text-red-500 font-bold">MP: 1710°C</span><span>2500°C</span>`;
                els.legend.innerHTML = `
                    <div class="flex items-center gap-2"><div class="w-4 h-4 rounded-full bg-slate-600"></div><span class="text-xs">Silicon</span></div>
                    <div class="flex items-center gap-2"><div class="w-4 h-4 rounded-full bg-red-500"></div><span class="text-xs">Oxygen</span></div>
                    <div class="flex items-center gap-2"><div class="w-8 h-1 bg-gray-400"></div><span class="text-[10px]">Covalent Bond</span></div>
                `;
            } else if (state.compound === 'metal') {
                metalGroup.visible = true;
                els.viewOptions.style.display = "none";
                styleActiveBtn(els.btnMetal);
                els.title.innerText = "Magnesium (Mg)";
                els.desc.innerText = "Giant Metallic Lattice";
                els.tempSlider.min = 20; els.tempSlider.max = 1200;
                els.tempLabels.innerHTML = `<span>20°C</span><span class="text-red-500 font-bold">MP: 650°C</span><span>1200°C</span>`;
                els.legend.innerHTML = `
                    <div class="flex items-center gap-2"><div class="w-4 h-4 rounded-full bg-slate-500"></div><span class="text-xs">Mg²⁺ Ion</span></div>
                    <div class="flex items-center gap-2"><div class="w-2 h-2 rounded-full bg-yellow-400"></div><span class="text-xs">Delocalised Electron</span></div>
                `;
            }

            updateStateCalculation();
        }

        function styleActiveBtn(btn) {
            btn.className = btn.className.replace('bg-gray-700', 'bg-amber-600').replace('border-gray-600', 'border-amber-600');
        }

        function updateStateCalculation() {
            state.isPowerOn = els.powerToggle.checked;
            electrodeGroup.visible = state.isPowerOn;
            els.tempDisplay.innerText = state.temp + "°C";

            if (state.compound === 'nacl') {
                state.nacl.isMolten = state.temp >= state.nacl.meltingPoint;
                let isFree = state.nacl.inSolution || state.nacl.isMolten;
                els.stateText.innerHTML = state.nacl.inSolution ? 'State: <span class="text-blue-400">Aqueous Solution</span>' : (state.nacl.isMolten ? 'State: <span class="text-orange-400">Liquid (Molten)</span>' : 'State: <span class="text-green-400">Solid Lattice</span>');
                if (state.isPowerOn) setConducting(isFree, isFree ? "Ions are free to carry charge to electrodes." : "Ions are locked in lattice.");
                else setConducting(false, "Switch on power to test.");
            
            } else if (state.compound === 'water') {
                if (state.temp < 0) { state.water.phase = 'solid'; els.stateText.innerHTML = 'State: <span class="text-blue-200">Solid (Ice)</span>'; }
                else if (state.temp < 100) { state.water.phase = 'liquid'; els.stateText.innerHTML = 'State: <span class="text-blue-500">Liquid (Water)</span>'; }
                else { state.water.phase = 'gas'; els.stateText.innerHTML = 'State: <span class="text-gray-400">Gas (Steam)</span>'; }
                if (state.isPowerOn) setConducting(false, "Simple molecules have no overall charge.");
                else setConducting(false, "Switch on power to test.");

            } else if (state.compound === 'sio2') {
                state.sio2.isMolten = state.temp >= state.sio2.meltingPoint;
                els.stateText.innerHTML = state.sio2.isMolten ? 'State: <span class="text-orange-400">Liquid (Molten)</span>' : 'State: <span class="text-green-400">Solid Lattice</span>';
                
                // SiO2 never conducts in this context
                if (state.isPowerOn) setConducting(false, "No ions or free electrons to carry charge.");
                else setConducting(false, "Switch on power to test.");
            } else if (state.compound === 'metal') {
                state.metal.isMolten = state.temp >= state.metal.meltingPoint;
                els.stateText.innerHTML = state.metal.isMolten ? 'State: <span class="text-orange-400">Liquid (Molten)</span>' : 'State: <span class="text-green-400">Solid Lattice</span>';
                
                if (state.isPowerOn) {
                    setConducting(true, "Delocalised electrons are free to move through the structure (Solid & Liquid).");
                } else {
                    setConducting(false, "Switch on power to test.");
                }
            }
        }

        function setConducting(isConducting, reason) {
            els.condReason.innerText = reason;
            if (isConducting) {
                els.condStatus.innerText = "CONDUCTING";
                els.condStatus.className = "text-xs text-green-400 font-bold";
                els.bulb.style.backgroundColor = "#fbbf24"; els.bulb.style.boxShadow = "0 0 15px #fbbf24";
            } else {
                els.condStatus.innerText = state.isPowerOn ? "NO CURRENT" : "OFF";
                els.condStatus.className = state.isPowerOn ? "text-xs text-red-400 font-bold" : "text-xs text-gray-400 font-bold";
                els.bulb.style.backgroundColor = "#374151"; els.bulb.style.boxShadow = "none";
            }
        }

        // --- Event Listeners ---
        els.btnNacl.addEventListener('click', () => { state.compound = 'nacl'; state.temp = 20; els.tempSlider.value = 20; updateUI(); });
        els.btnWater.addEventListener('click', () => { state.compound = 'water'; state.temp = -20; els.tempSlider.value = -20; updateUI(); });
        els.btnSio2.addEventListener('click', () => { state.compound = 'sio2'; state.temp = 20; els.tempSlider.value = 20; updateUI(); });
        els.btnMetal.addEventListener('click', () => { state.compound = 'metal'; state.temp = 20; els.tempSlider.value = 20; updateUI(); });

        els.btnPure.addEventListener('click', () => { state.nacl.inSolution = false; els.btnPure.className = els.btnPure.className.replace('bg-gray-700', 'bg-blue-600').replace('text-gray-300', 'text-white').replace('border-gray-600', 'border-blue-600'); els.btnSolution.className = els.btnSolution.className.replace('bg-blue-600', 'bg-gray-700').replace('text-white', 'text-gray-300').replace('border-blue-600', 'border-gray-600'); if(state.temp < state.nacl.meltingPoint) ions.forEach(i => i.liquidPos.copy(i.basePos)); updateStateCalculation(); });
        els.btnSolution.addEventListener('click', () => { state.nacl.inSolution = true; els.btnSolution.className = els.btnSolution.className.replace('bg-gray-700', 'bg-blue-600').replace('text-gray-300', 'text-white').replace('border-gray-600', 'border-blue-600'); els.btnPure.className = els.btnPure.className.replace('bg-blue-600', 'bg-gray-700').replace('text-white', 'text-gray-300').replace('border-blue-600', 'border-gray-600'); updateStateCalculation(); });

        els.tempSlider.addEventListener('input', (e) => { state.temp = parseInt(e.target.value); updateStateCalculation(); });
        els.powerToggle.addEventListener('change', (e) => { state.isPowerOn = e.target.checked; updateStateCalculation(); });
        document.querySelectorAll('input[name="viewMode"]').forEach(radio => { radio.addEventListener('change', (e) => { state.nacl.viewMode = e.target.value; state.sio2.viewMode = e.target.value; }); });
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

        function animate() { requestAnimationFrame(animate); controls.update(); updatePhysics(); renderer.render(scene, camera); }

        initNaCl(); initWater(); initSiO2(); initMetal(); updateUI(); animate();

    </script>
</body>
</html>
